{
  "language": "Solidity",
  "sources": {
    "contracts/Beacon.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"./interfaces/IBeaconInterface.sol\";\r\n\r\ncontract Beacon is IBeaconInterface, Ownable {\r\n    // Storage\r\n\r\n    /// @dev Current implementation address for this beacon,\r\n    ///      i.e. the address which all beacon proxies will delegatecall to.\r\n    address public implementation;\r\n\r\n    // Constructor\r\n\r\n    /// @param implementationAddress The address all beaconProxies will delegatecall to.\r\n    constructor(address implementationAddress) {\r\n        _setImplementationAddress(implementationAddress);\r\n    }\r\n\r\n    /// @dev Upgrades the implementation address of the beacon or the address that the beacon points to.\r\n    /// @param newImplementation Address of implementation that the beacon should be upgraded to.\r\n    function upgradeImplementationTo(address newImplementation)\r\n        public\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        _setImplementationAddress(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    function _setImplementationAddress(address newImplementation) internal {\r\n        require(\r\n            Address.isContract(newImplementation),\r\n            \"UpgradeableBeacon: implementation is not a contract\"\r\n        );\r\n        implementation = newImplementation;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IBeaconInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\ninterface IBeaconInterface {\r\n    /// @dev Event emitted when the address that the beacon is pointing to is upgraded.\r\n    /// @return address of the new implementation.\r\n    event Upgraded(address indexed newImplementation);\r\n\r\n    function implementation() external view returns (address);\r\n\r\n    function upgradeImplementationTo(address newImplementation) external;\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/VaultRegistry/BeaconManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\r\n\r\nimport { Beacon } from \"../Beacon.sol\";\r\n\r\n/**\r\n * @dev contract managing beacon data for all vaults\r\n */\r\ncontract BeaconManager is OwnableUpgradeable, AccessControlUpgradeable {\r\n    /// @dev Beacon registeration event\r\n    /// @param _name The name of the beacon getting registered\r\n    /// @param _address The implementation address that this beacon will point to\r\n    /// @param _ipfsHash IPFS hash for the config of this beacon\r\n    event BeaconRegistered(string _name, address _address, string _ipfsHash);\r\n\r\n    /// @dev Beacon config updation event\r\n    /// @param _name The name of the beacon getting registered\r\n    /// @param _ipfsHash updated IPFS hash for the config of this beacon\r\n    event BeaconConfigUpdated(string _name, string _ipfsHash);\r\n\r\n    /// @dev Beacon deregisteration event\r\n    /// @param _name The name of the beacon getting registered\r\n    event BeaconDeregistered(string _name);\r\n\r\n    // Beacon creator, used to create and register new beacons for new vault types\r\n    bytes32 internal constant BEACON_CREATOR = keccak256(\"BEACON_CREATOR\");\r\n\r\n    // Mapping beaconName => beacon address. Used to find the beacon for a given vault type.\r\n    mapping(string => address) public beaconAddresses;\r\n\r\n    // Mapping address => beaconName. Used to find what vault type a given beacon or vault is.\r\n    // Note that beaconTypes applies to both beacons and vaults.\r\n    mapping(address => string) public beaconTypes;\r\n\r\n    /// @dev Registers a beacon associated with a new vault type\r\n    /// @param _name The name of the vault type this beacon will be using\r\n    /// @param _address The address of the beacon contract\r\n    /// @param _ipfsConfigForBeacon IPFS hash for the config of this beacon\r\n    /// @dev This function is only available to the beacon creator\r\n    /// @dev Registers any address as a new beacon. Useful for alternative beacon types (i.e. a contract which will use a proxy structure other than the standard beacon).\r\n    function registerBeacon(\r\n        string calldata _name,\r\n        address _address,\r\n        string memory _ipfsConfigForBeacon\r\n    ) public onlyRole(BEACON_CREATOR) {\r\n        // Ensure no beacon exists with given name, so that this function can't edit an existing beacon address\r\n        require(beaconAddresses[_name] == address(0), \"Beacon already exists\");\r\n\r\n        // Register beacon\r\n        beaconAddresses[_name] = _address;\r\n        beaconTypes[_address] = _name;\r\n        emit BeaconRegistered(_name, _address, _ipfsConfigForBeacon);\r\n    }\r\n\r\n    /// @dev Deploy new beacon for a new vault type AND register it\r\n    /// @param _address The address of the implementation for the beacon\r\n    /// @param _name The name of the beacon (identifier)\r\n    /// @param _ipfsConfigForBeacon IPFS hash for the config of this beacon\r\n    /// note that the contract registered as a beacon should not be used as a vault, to avoid confusion.\r\n    function deployAndRegisterBeacon(\r\n        address _address,\r\n        string calldata _name,\r\n        string calldata _ipfsConfigForBeacon\r\n    ) external onlyRole(BEACON_CREATOR) returns (address) {\r\n        // Ensure no beacon exists with given name, so that this function can't edit an existing beacon address\r\n        require(beaconAddresses[_name] == address(0), \"Beacon already exists\");\r\n\r\n        // Deploy new beacon instance\r\n        Beacon newBeacon = new Beacon(_address);\r\n\r\n        // Transfer ownership to governance\r\n        newBeacon.transferOwnership(owner());\r\n\r\n        // Record beacon address at beacon name, so that new vaults can be created with this beacon by passing in beacon name\r\n        beaconAddresses[_name] = address(newBeacon);\r\n        beaconTypes[address(newBeacon)] = _name;\r\n\r\n        emit BeaconRegistered(_name, _address, _ipfsConfigForBeacon);\r\n        return address(newBeacon);\r\n    }\r\n\r\n    /// @dev Updates the ipfs link storing the beaconConfig\r\n    /// @param _name The name of the beacon (identifier)\r\n    /// @param _newIPFSConfigForBeacon IPFS hash for the config of this beacon\r\n    function updateBeaconConfig(\r\n        string calldata _name,\r\n        string calldata _newIPFSConfigForBeacon\r\n    ) external onlyRole(BEACON_CREATOR) {\r\n        require(beaconAddresses[_name] != address(0), \"Beacon does not exist\");\r\n        emit BeaconConfigUpdated(_name, _newIPFSConfigForBeacon);\r\n    }\r\n\r\n    /// @dev Removes a beacon associated with a vault type\r\n    /// @param _name The name of the beacon (identifier)\r\n    /// @dev This will stop the creation of more vaults of the type provided\r\n    function deregisterBeacon(string calldata _name)\r\n        external\r\n        onlyRole(BEACON_CREATOR)\r\n    {\r\n        emit BeaconDeregistered(_name);\r\n        delete beaconAddresses[_name];\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/VaultRegistry/InterfaceManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport { BeaconManager } from \"./BeaconManager.sol\";\r\n\r\ncontract InterfaceManager is BeaconManager {\r\n    bytes32 internal constant INTERFACE_EDITOR = keccak256(\"INTERFACE_EDITOR\");\r\n\r\n    error IncorrectArrayLengths(\r\n        uint256 selectorLength,\r\n        uint256 isImplementedLength\r\n    );\r\n\r\n    /**\r\n     * @dev mapping beacon name => function selector => isImplemented\r\n     */\r\n    mapping(string => mapping(bytes4 => bool)) public interfaceImplementations;\r\n\r\n    /**\r\n     * @dev add interface info to given beacon\r\n     */\r\n    function updateInterfaceImplementations(\r\n        string calldata beaconName,\r\n        bytes4[] calldata selectors,\r\n        bool[] calldata isImplemented\r\n    ) external onlyRole(INTERFACE_EDITOR) {\r\n        // Require that array lengths match\r\n        if (selectors.length != isImplemented.length) {\r\n            revert IncorrectArrayLengths(\r\n                selectors.length,\r\n                isImplemented.length\r\n            );\r\n        }\r\n\r\n        // Set\r\n        for (uint256 i; i != selectors.length; ++i) {\r\n            interfaceImplementations[beaconName][selectors[i]] = isImplemented[\r\n                i\r\n            ];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev check whether msg.sender supports a given interface id. Used to support ERC165 from a central location.\r\n     * @param interfaceId the interface id to check\r\n     */\r\n    function doISupportInterface(bytes4 interfaceId)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        string memory beaconOfSender = beaconTypes[msg.sender];\r\n        return interfaceImplementations[beaconOfSender][interfaceId];\r\n    }\r\n}\r\n"
    },
    "contracts/VaultRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"./interfaces/IStrategyRegistry.sol\";\r\n\r\n// Factory\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\r\n\r\n// Proxy Support\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\r\n\r\n// Vault support\r\nimport \"./interfaces/IVaultRegistry.sol\";\r\nimport \"./interfaces/IImplementation.sol\";\r\n\r\n// Beacon support\r\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\r\n\r\n// Governance\r\nimport { IOrchestrator } from \"./interfaces/IOrchestrator.sol\";\r\n\r\n// Inheritance\r\nimport { InterfaceManager } from \"./VaultRegistry/InterfaceManager.sol\";\r\n\r\n/// @title A registry for vaults\r\n/// @author Steer Protocol\r\n/// @dev All vaults are created through this contract\r\ncontract VaultRegistry is\r\n    Initializable,\r\n    UUPSUpgradeable,\r\n    PausableUpgradeable,\r\n    InterfaceManager\r\n{\r\n    /// @dev Vault creation event\r\n    /// @param deployer The address of the deployer\r\n    /// @param vault The address of the vault\r\n    /// @param tokenId ERC721 token id for the vault\r\n    event VaultCreated(\r\n        address deployer,\r\n        address vault,\r\n        string beaconName,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /// @dev Vault state change event\r\n    /// @param vault The address of the vault\r\n    /// @param newState The new state of the vault\r\n    event VaultStateChanged(address indexed vault, VaultState newState);\r\n\r\n    /**\r\n     * @dev all necessary data for vault. Name and symbol are stored in vault's ERC20. Owner is stored with tokenId in StrategyRegistry.\r\n     * tokenId: NFT identifier number\r\n     * vaultAddress: address of vault this describes\r\n     * state: state of the vault.\r\n     */\r\n    struct VaultData {\r\n        VaultState state;\r\n        uint256 tokenId; //NFT ownership of this vault and all others that use vault's exec bundle\r\n        uint256 vaultID; //unique identifier for this vault and strategy token id\r\n        string payloadIpfs;\r\n        address vaultAddress;\r\n    }\r\n\r\n    /**\r\n     * PendingApproval: strategy is submitted but has not yet been approved by the owner\r\n     * PendingThreshold: strategy is approved but has not yet reached the threshold of TVL required\r\n     * Paused: strategy was active but something went wrong, so now it's paused\r\n     * Active: strategy is active and can be used\r\n     * Retired: strategy is retired and can no longer be used\r\n     */\r\n    enum VaultState {\r\n        PendingApproval,\r\n        PendingThreshold,\r\n        Paused,\r\n        Active,\r\n        Retired\r\n    }\r\n\r\n    // Pause role for disabling vault creation in the event of an emergency\r\n    bytes32 internal constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\r\n\r\n    // Governance role for controlling aspects of the registry\r\n    bytes32 internal constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\r\n\r\n    // Total vault count\r\n    uint256 public totalVaultCount;\r\n\r\n    // Mapping for vaults to their details\r\n    // Vault Address => VaultDetails\r\n    mapping(address => VaultData) internal vaults;\r\n\r\n    // Mapping from strategy token ID (Execution Bundle) to list of linked vault IDs\r\n    //  Strategy ID => (VaultId => vault address)\r\n    mapping(uint256 => mapping(uint256 => address)) public linkedVaults;\r\n\r\n    // Mapping for strategy token ID to number of vaults created using that strategy.\r\n    mapping(uint256 => uint256) internal linkedVaultCounts;\r\n\r\n    // Orchestrator contract, able to control a deployed vault\r\n    IOrchestrator public orchestrator;\r\n\r\n    // Internal Governance address\r\n    address internal internalGovernance;\r\n\r\n    // Strategy registry address--used for strategy IDs\r\n    IStrategyRegistry public strategyRegistry;\r\n\r\n    // Misc addresses--used to point vaults towards the correct contracts.\r\n    address public whitelistRegistry;\r\n\r\n    /// @dev intializes the vault registry\r\n    /// @param _orchestrator The address of the orchestrator\r\n    /// @param _strategyRegistry The address of the strategy registry\r\n    /// @param _internalGovernance The address of Internal Governance\r\n    function initialize(\r\n        address payable _orchestrator,\r\n        address _strategyRegistry,\r\n        address _internalGovernance,\r\n        address _whitelistRegistry\r\n    ) public initializer {\r\n        __UUPSUpgradeable_init();\r\n        __Ownable_init();\r\n        __AccessControl_init();\r\n        __Pausable_init();\r\n\r\n        // Instantiate the orchestrator\r\n        orchestrator = IOrchestrator(_orchestrator);\r\n        internalGovernance = _internalGovernance;\r\n\r\n        // Instantiate the strategy registry\r\n        strategyRegistry = IStrategyRegistry(_strategyRegistry);\r\n\r\n        // Record misc addresses\r\n        whitelistRegistry = _whitelistRegistry;\r\n\r\n        // Access Control Setup\r\n        // Grant pauser, beacon creator, and ERC165 editor roles to Steer multisig\r\n        _setupRole(PAUSER_ROLE, _msgSender()); // Grant pauser role to Steer multisig\r\n        _setupRole(BEACON_CREATOR, _msgSender()); // Grant beacon creator role to Steer multisig\r\n        _setupRole(INTERFACE_EDITOR, _msgSender()); // Grant ERC165 editor role to Steer multisig\r\n        // Grant admin role to internal governance (for now)\r\n        _setupRole(DEFAULT_ADMIN_ROLE, internalGovernance);\r\n    }\r\n\r\n    /// @dev Creates a new vault with the given strategy\r\n    /// @dev Registers an execution bundle, mints an NFT and mappings it to execution bundle and it's details.\r\n    /// @param _params is extra parameters in vault.\r\n    /// @param _tokenId is the NFT of the execution bundle this vault will be using. Note that if the given tokenID does not yet exist, the vault will remain inactive.\r\n    /// @param _beaconName beacon identifier of vault type to be created\r\n    /// @dev owner is set as msg.sender.\r\n    function createVault(\r\n        bytes calldata _params,\r\n        uint256 _tokenId,\r\n        string calldata _beaconName,\r\n        string calldata _payloadIpfs\r\n    ) external whenNotPaused returns (address) {\r\n        // Retrieve the address for the vault type to be created\r\n        address beaconAddress = beaconAddresses[_beaconName];\r\n\r\n        // Make sure that we have a beacon for the provided vault type\r\n        // This ensures that a bad vault type hasn't been provided\r\n        require(beaconAddress != address(0), \"Beacon is not present\");\r\n\r\n        // Create new vault implementation\r\n        BeaconProxy newVault = new BeaconProxy(\r\n            beaconAddress,\r\n            abi.encodeWithSelector(\r\n                IImplementation.initialize.selector,\r\n                address(orchestrator),\r\n                owner(),\r\n                internalGovernance,\r\n                _params\r\n            )\r\n        );\r\n\r\n        // Add beacon type to mapping\r\n        beaconTypes[address(newVault)] = _beaconName;\r\n\r\n        // Add enumeration for the vault\r\n        _addLinkedVaultsEnumeration(_tokenId, address(newVault), _payloadIpfs);\r\n\r\n        // Emit vault details\r\n        emit VaultCreated(\r\n            msg.sender,\r\n            address(newVault),\r\n            _beaconName,\r\n            _tokenId\r\n        );\r\n\r\n        // Return the address of the new vault\r\n        return address(newVault);\r\n    }\r\n\r\n    /// @dev Updates the vault state and emits a VaultStateChanged event\r\n    /// @param _vault The address of the vault\r\n    /// @param _newState The new state of the vault\r\n    /// @dev This function is only available to the registry owner.\r\n    function updateVaultState(address _vault, VaultState _newState)\r\n        external\r\n        onlyOwner\r\n    {\r\n        vaults[_vault].state = _newState;\r\n        emit VaultStateChanged(_vault, _newState);\r\n    }\r\n\r\n    /// @dev Retrieves the creator of a given vault\r\n    /// @param _vault The address of the vault\r\n    /// @return The address of the creator\r\n    function getStrategyCreatorForVault(address _vault)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return strategyRegistry.ownerOf(vaults[_vault].tokenId);\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        override\r\n        onlyOwner\r\n    {}\r\n\r\n    /// @dev Pauses the minting of the ERC721 tokens for the vault\r\n    /// @dev This function is only available to the pauser role\r\n    function pause() public onlyRole(PAUSER_ROLE) {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyRole(PAUSER_ROLE) {\r\n        _unpause();\r\n    }\r\n\r\n    /// @dev Provides support for vault enumeration\r\n    /// @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n    /// @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n    /// @param _deployedAddress address of the new vault\r\n    function _addLinkedVaultsEnumeration(\r\n        uint256 _tokenId,\r\n        address _deployedAddress,\r\n        string calldata _payloadIpfs\r\n    ) internal {\r\n        // Get the current count of how many vaults have been created from this strategy.\r\n        uint256 currentCount = linkedVaultCounts[_tokenId];\r\n\r\n        // Using _tokenId and count as map keys, add the vault to the list of linked vaults\r\n        linkedVaults[_tokenId][currentCount] = _deployedAddress;\r\n\r\n        // Increment the count of how many vaults have been created from a given strategy\r\n        linkedVaultCounts[_tokenId] = currentCount + 1;\r\n\r\n        // Store any vault specific data via the _deployedAddress\r\n        vaults[_deployedAddress] = VaultData(\r\n            VaultState.PendingThreshold,\r\n            _tokenId,\r\n            ++totalVaultCount,\r\n            _payloadIpfs,\r\n            _deployedAddress\r\n        );\r\n    }\r\n\r\n    /// @dev Retrieves the details of a given vault by address\r\n    /// @param _address The address of the vault\r\n    /// @return The details of the vault\r\n    function getVaultDetails(address _address)\r\n        public\r\n        view\r\n        returns (VaultData memory)\r\n    {\r\n        return vaults[_address];\r\n    }\r\n\r\n    /// @dev Retrieves the vault count by vault token id\r\n    /// @param _tokenId The token id of the vault\r\n    /// @return The count of the vault\r\n    function getVaultCountByStrategyId(uint256 _tokenId)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return linkedVaultCounts[_tokenId];\r\n    }\r\n\r\n    /// @dev Retrieves the vault by vault token id and vault index\r\n    /// @param _tokenId The token id of the vault\r\n    /// @param _vaultId The index of the vault\r\n    /// @return Vault details\r\n    function getVaultByStrategyAndIndex(uint256 _tokenId, uint256 _vaultId)\r\n        public\r\n        view\r\n        returns (VaultData memory)\r\n    {\r\n        return vaults[linkedVaults[_tokenId][_vaultId]];\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IStrategyRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\r\n\r\ninterface IStrategyRegistry is\r\n    IERC721Upgradeable,\r\n    IERC721EnumerableUpgradeable\r\n{\r\n    struct RegisteredStrategy {\r\n        uint256 id;\r\n        string name;\r\n        address owner;\r\n        string execBundle; //IPFS reference of execution bundle\r\n        //GasVault stuff\r\n        uint128 maxGasCost;\r\n        uint128 maxGasPerAction;\r\n    }\r\n\r\n    function getStrategyAddress(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function getStrategyOwner(uint256 tokenId) external view returns (address);\r\n\r\n    /**\r\n     * @dev Create NFT for execution bundle.\r\n     * @param name The name of the strategy.\r\n     * @param execBundle The IPFS reference of the execution bundle.\r\n     * @return newStrategyTokenId The token ID of the NFT.\r\n     */\r\n    function createStrategy(\r\n        address strategyCreator,\r\n        string memory name,\r\n        string memory execBundle,\r\n        uint128 maxGasCost,\r\n        uint128 maxGasPerAction\r\n    ) external returns (uint256 newStrategyTokenId);\r\n\r\n    //\r\n    // Todo: add to utility library\r\n    //\r\n    function addressToString(address _address)\r\n        external\r\n        pure\r\n        returns (string memory);\r\n\r\n    /**\r\n     * @dev Pauses all token transfers.\r\n     *\r\n     * See {ERC721Pausable} and {Pausable-_pause}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the `PAUSER_ROLE`.\r\n     */\r\n    function pause() external;\r\n\r\n    /**\r\n     * @dev Unpauses all token transfers.\r\n     *\r\n     * See {ERC721Pausable} and {Pausable-_unpause}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the `PAUSER_ROLE`.\r\n     */\r\n    function unpause() external;\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    function getRegisteredStrategy(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (IStrategyRegistry.RegisteredStrategy memory);\r\n\r\n    /**\r\n     * @dev parameters users set for what constitutes an acceptable use of their funds. Can only be set by NFT owner.\r\n     * @param _tokenId is the token ID of the execution bundle.\r\n     * @param _maxGasCost is highest acceptable price to pay per gas, in terms of gwei.\r\n     * @param _maxGasPerMethod is max amount of gas to be sent in one method.\r\n     * @param _maxMethods is the maximum number of methods that can be executed in one action.\r\n     */\r\n    function setGasParameters(\r\n        uint256 _tokenId,\r\n        uint128 _maxGasCost,\r\n        uint128 _maxGasPerMethod,\r\n        uint16 _maxMethods\r\n    ) external;\r\n\r\n    //function getExecutionBundle(uint256 tokenId) external view returns (string memory);\r\n\r\n    function baseURI() external view returns (string memory);\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IVaultRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\npragma abicoder v2; //Used this because function getAssetSymbols uses string[2]\r\n\r\nimport { IStrategyRegistry } from \"./IStrategyRegistry.sol\";\r\nimport { IOrchestrator } from \"./IOrchestrator.sol\";\r\n\r\ninterface IVaultRegistry {\r\n    /**\r\n     * PendingApproval: strategy is submitted but has not yet been approved by the owner\r\n     * PendingThreshold: strategy is approved but has not yet reached the threshold of TVL required\r\n     * Paused: strategy was active but something went wrong, so now it's paused\r\n     * Active: strategy is active and can be used\r\n     * Retired: strategy is retired and can no longer be used\r\n     */\r\n    enum VaultState {\r\n        PendingApproval,\r\n        PendingThreshold,\r\n        Paused,\r\n        Active,\r\n        Retired\r\n    }\r\n\r\n    /**\r\n     * @dev all necessary data for vault. Name and symbol are stored in vault's ERC20. Owner is stored with tokenId in StrategyRegistry.\r\n     * tokenId: NFT identifier number\r\n     * vaultAddress: address of vault this describes\r\n     * state: state of the vault.\r\n     */\r\n    struct VaultData {\r\n        VaultState state;\r\n        uint256 tokenId; //NFT ownership of this vault and all others that use vault's exec bundle\r\n        uint256 vaultID; //unique identifier for this vault and strategy token id\r\n        string payloadIpfs;\r\n        address vaultAddress;\r\n    }\r\n\r\n    /// @dev Vault creation event\r\n    /// @param deployer The address of the deployer\r\n    /// @param vault The address of the vault\r\n    /// @param tokenId ERC721 token id for the vault\r\n    event VaultCreated(\r\n        address deployer,\r\n        address vault,\r\n        string beaconName,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /// @dev Vault state change event\r\n    /// @param vault The address of the vault\r\n    /// @param newState The new state of the vault\r\n    event VaultStateChanged(address indexed vault, VaultState newState);\r\n\r\n    // Total vault count.\r\n    function totalVaultCount() external view returns (uint256);\r\n\r\n    function whitelistRegistry() external view returns (address);\r\n\r\n    function orchestrator() external view returns (IOrchestrator);\r\n\r\n    function beaconAddresses(string calldata) external view returns (address);\r\n\r\n    function beaconTypes(address) external view returns (string memory);\r\n\r\n    // Interface for the strategy registry\r\n    function strategyRegistry() external view returns (IStrategyRegistry);\r\n\r\n    /// @dev intializes the vault registry\r\n    /// @param _orchestrator The address of the orchestrator\r\n    /// @param _strategyRegistry The address of the strategy registry\r\n    /// @param _whitelistRegistry The address of the whitelist registry\r\n    function initialize(\r\n        address payable _orchestrator,\r\n        address _strategyRegistry,\r\n        address _internalGovernance,\r\n        address _whitelistRegistry\r\n    ) external;\r\n\r\n    /// @dev Registers a beacon associated with a new vault type\r\n    /// @param _name The name of the vault type this beacon will be using\r\n    /// @param _address The address of the upgrade beacon\r\n    /// @param _ipfsConfigForBeacon IPFS hash for the config of this beacon\r\n    function registerBeacon(\r\n        string calldata _name,\r\n        address _address,\r\n        string calldata _ipfsConfigForBeacon\r\n    ) external;\r\n\r\n    /// @dev Deploy new beacon for a new vault type AND register it\r\n    /// @param _address The address of the implementation for the beacon\r\n    /// @param _name The name of the beacon (identifier)\r\n    /// @param _ipfsConfigForBeacon IPFS hash for the config of this beacon\r\n    function deployAndRegisterBeacon(\r\n        address _address,\r\n        string calldata _name,\r\n        string calldata _ipfsConfigForBeacon\r\n    ) external returns (address);\r\n\r\n    /// @dev Removes a beacon associated with a vault type\r\n    /// @param _name The name of the beacon (identifier)\r\n    /// @dev This will stop the creation of more vaults of the type provided\r\n    function deregisterBeacon(string calldata _name) external;\r\n\r\n    /// @dev Creates a new vault with the given strategy\r\n    /// @dev Registers an execution bundle, mints an NFT and mappings it to execution bundle and it's details.\r\n    /// @param _params is extra parameters in vault.\r\n    /// @param _tokenId is the NFT of the execution bundle this vault will be using.\r\n    /// @param _beaconName beacon identifier of vault type to be created\r\n    /// @dev owner is set as msg.sender.\r\n    function createVault(\r\n        bytes calldata _params,\r\n        uint256 _tokenId,\r\n        string calldata _beaconName,\r\n        string calldata strategyData\r\n    ) external returns (address);\r\n\r\n    /// @dev Updates the vault state and emits a VaultStateChanged event\r\n    /// @param _vault The address of the vault\r\n    /// @param _newState The new state of the vault\r\n    /// @dev This function is only available to the registry owner\r\n    function updateVaultState(address _vault, VaultState _newState) external;\r\n\r\n    /// @dev Retrieves the creator of a given vault\r\n    /// @param _vault The address of the vault\r\n    /// @return The address of the creator\r\n    function getStrategyCreatorForVault(address _vault)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /// @dev This function is only available to the pauser role\r\n    function pause() external;\r\n\r\n    function unpause() external;\r\n\r\n    /// @dev Retrieves the details of a given vault by address\r\n    /// @param _address The address of the vault\r\n    /// @return The details of the vault\r\n    function getVaultDetails(address _address)\r\n        external\r\n        view\r\n        returns (VaultData memory);\r\n\r\n    /// @dev Retrieves the vault count by vault token id\r\n    /// @param _tokenId The token id of the vault\r\n    /// @return The count of the vault\r\n    function getVaultCountByStrategyId(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /// @dev Retrieves the vault by vault token id and vault index\r\n    /// @param _tokenId The token id of the vault\r\n    /// @param _vaultId The index of the vault\r\n    /// @return Vault details\r\n    function getVaultByStrategyAndIndex(uint256 _tokenId, uint256 _vaultId)\r\n        external\r\n        view\r\n        returns (VaultData memory);\r\n}\r\n"
    },
    "contracts/interfaces/IImplementation.sol": {
      "content": "// SPDX-License-Identifier: BSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\ninterface IImplementation {\r\n    /// @dev To initialize a vault.\r\n    function initialize(\r\n        address _orchestrator,\r\n        address _steer,\r\n        address _internalGovernance,\r\n        bytes calldata _params\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/IOrchestrator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\n/**\r\n * @dev Interface of the Orchestrator.\r\n */\r\ninterface IOrchestrator {\r\n    enum ActionState {\r\n        PENDING,\r\n        COMPLETED\r\n    }\r\n\r\n    /**\r\n     * @dev MUST trigger when actions are executed.\r\n     * @param actionHash: keccak256(targetAddress, jobEpoch, calldatas) used to identify this action\r\n     * @param from: the address of the keeper that executed this action\r\n     * @param rewardPerAction: SteerToken reward for this action, to be supplied to operator nodes.\r\n     */\r\n    event ActionExecuted(\r\n        bytes32 indexed actionHash,\r\n        address from,\r\n        uint256 rewardPerAction\r\n    );\r\n    event ActionFailed(bytes32 indexed actionHash);\r\n    event Vote(\r\n        bytes32 indexed actionHash,\r\n        address indexed from,\r\n        bool approved\r\n    );\r\n\r\n    // If an action is approved by >= approvalThresholdPercent members, it is approved\r\n    function actionThresholdPercent() external view returns (uint256);\r\n\r\n    // Address of GasVault, which is the contract used to recompense keepers for gas they spent executing actions\r\n    function gasVault() external view returns (address);\r\n\r\n    // Address of Keeper Registry, which handles keeper verification\r\n    function keeperRegistry() external view returns (address);\r\n\r\n    // Operator node action participation reward. Currently unused.\r\n    function rewardPerAction() external view returns (uint256);\r\n\r\n    /*\r\n        bytes32 is hash of action. Calculated using keccak256(abi.encode(targetAddress, jobEpoch, calldatas))\r\n\r\n        Action approval meaning:\r\n        0: Pending\r\n        1: Approved\r\n        Both votes and overall approval status follow this standard.\r\n    */\r\n    function actions(bytes32) external view returns (ActionState);\r\n\r\n    /*  \r\n        actionHash => uint256 where each bit represents one keeper vote.\r\n    */\r\n    function voteBitmaps(bytes32) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev initialize the Orchestrator\r\n     * @param _keeperRegistry address of the keeper registry\r\n     * @param _rewardPerAction is # of SteerToken to give to operator nodes for each completed action (currently unused)\r\n     */\r\n    function initialize(address _keeperRegistry, uint256 _rewardPerAction)\r\n        external;\r\n\r\n    /**\r\n     * @dev allows owner to set/update gas vault address. Mainly used to resolve mutual dependency.\r\n     */\r\n    function setGasVault(address _gasVault) external;\r\n\r\n    /**\r\n     * @dev set the reward given to operator nodes for their participation in a strategy calculation\r\n     * @param _rewardPerAction is amount of steer token to be earned as a reward, per participating operator node per action.\r\n     */\r\n    function setRewardPerAction(uint256 _rewardPerAction) external;\r\n\r\n    /**\r\n     * @dev vote (if you are a keeper) on a given action proposal\r\n     * @param actionHash is the hash of the action to be voted on\r\n     * @param vote is the vote to be cast. false: reject, true: approve. false only has an effect if the keeper previously voted true. It resets their vote to false.\r\n     */\r\n    function voteOnAction(bytes32 actionHash, bool vote) external;\r\n\r\n    /**\r\n     * @dev Returns true if an action with given `actionId` is approved by all existing members of the group.\r\n     * Its up to the contract creators to decide if this method should look at majority votes (based on ownership)\r\n     * or if it should ask consent of all the users irrespective of their ownerships.\r\n     */\r\n    function actionApprovalStatus(bytes32 actionHash)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Executes the action referenced by the given `actionId` as long as it is approved actionThresholdPercent of group.\r\n     * The executeAction executes all methods as part of given action in an atomic way (either all should succeed or none should succeed).\r\n     * Once executed, the action should be set as executed (state=3) so that it cannot be executed again.\r\n\r\n     * @param targetAddress is the address which will be receiving the action's calls.\r\n     * @param jobEpoch is the job epoch of this action.\r\n     * @param calldatas is the COMPLETE calldata of each method to be called\r\n     * note that the hash is created using the sliced calldata, but here it must be complete or the method will revert.\r\n     * @param timeIndependentLengths--For each calldata, the number of bytes that is NOT time-sensitive. If no calldatas are time-sensitive, just pass an empty array.\r\n     * @param jobHash is the identifier for the job this action is related to. This is used for DynamicJobs to identify separate jobs to the subgraph.\r\n     * @return actionState corresponding to post-execution action state. Pending if execution failed, Completed if execution succeeded.\r\n     */\r\n    function executeAction(\r\n        address targetAddress,\r\n        uint256 jobEpoch,\r\n        bytes[] calldata calldatas,\r\n        uint256[] calldata timeIndependentLengths,\r\n        bytes32 jobHash\r\n    ) external returns (ActionState);\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n        __UUPSUpgradeable_init_unchained();\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            _functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/tests/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\npragma solidity 0.8.12;\r\n\r\ncontract TestERC20 is ERC20 {\r\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\r\n        _mint(msg.sender, 10**50);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
    },
    "contracts/SteerPeriphery.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.7.6;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\nimport { ERC165CheckerUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\r\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\r\n\r\nimport { ISteerPeriphery } from \"./interfaces/ISteerPeriphery.sol\";\r\nimport { IStrategyRegistry } from \"./interfaces/IStrategyRegistry.sol\";\r\nimport { IVaultRegistry } from \"./interfaces/IVaultRegistry.sol\";\r\nimport { IStakingRewards } from \"./interfaces/IStakingRewards.sol\";\r\nimport { IMultiPositionManager } from \"./interfaces/IMultiPositionManager.sol\";\r\nimport { IBaseDeposit } from \"./interfaces/IBaseDeposit.sol\";\r\n\r\n/// @title Periphery contract to facilitate common actions on the protocol\r\n/// @author Steer Protocol\r\n/// @dev You can use this contract to enumerate strategy and vault details but also create, join, and leave vaults\r\n/// @dev This function should be used when doing protocol integrations\r\ncontract SteerPeriphery is\r\n    ISteerPeriphery,\r\n    Initializable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    using ERC165CheckerUpgradeable for address;\r\n\r\n    // Storage\r\n\r\n    address internal strategyRegistry;\r\n    address internal vaultRegistry;\r\n    address internal stakingRewards;\r\n\r\n    /// @notice The IPFS reference of the node configuration.\r\n    string public nodeConfig;\r\n\r\n    // External Functions\r\n\r\n    function initialize(\r\n        address _strategyRegistry,\r\n        address _vaultRegistry,\r\n        address _stakingRewards,\r\n        string calldata _nodeConfig\r\n    ) external initializer {\r\n        __UUPSUpgradeable_init();\r\n        __Ownable_init();\r\n        strategyRegistry = _strategyRegistry;\r\n        vaultRegistry = _vaultRegistry;\r\n        stakingRewards = _stakingRewards;\r\n        nodeConfig = _nodeConfig;\r\n    }\r\n\r\n    /// @dev Deposits tokens in proportion to the vault's current holdings.\r\n    /// @dev These tokens sit in the vault and are not used for liquidity on\r\n    ///      Uniswap until the next rebalance.\r\n    /// @param vaultAddress The address of the vault to deposit to\r\n    /// @param amount0Desired Max amount of token0 to deposit\r\n    /// @param amount1Desired Max amount of token1 to deposit\r\n    /// @param amount0Min Revert if resulting `amount0` is less than this\r\n    /// @param amount1Min Revert if resulting `amount1` is less than this\r\n    /// @param to Recipient of shares\r\n    function deposit(\r\n        address vaultAddress,\r\n        uint256 amount0Desired,\r\n        uint256 amount1Desired,\r\n        uint256 amount0Min,\r\n        uint256 amount1Min,\r\n        address to\r\n    ) external {\r\n        _deposit(\r\n            vaultAddress,\r\n            amount0Desired,\r\n            amount1Desired,\r\n            amount0Min,\r\n            amount1Min,\r\n            to\r\n        );\r\n    }\r\n\r\n    /// @dev Deposits tokens in proportion to the vault's current holdings and stake the share.\r\n    /// @dev These tokens sit in the vault and are not used for liquidity on\r\n    ///      Uniswap until the next rebalance.\r\n    /// @param vaultAddress The address of the vault to deposit to\r\n    /// @param amount0Desired Max amount of token0 to deposit\r\n    /// @param amount1Desired Max amount of token1 to deposit\r\n    /// @param amount0Min Revert if resulting `amount0` is less than this\r\n    /// @param amount1Min Revert if resulting `amount1` is less than this\r\n    /// @param poolId The id of the pool in which the share should be staked\r\n    function depositAndStake(\r\n        address vaultAddress,\r\n        uint256 amount0Desired,\r\n        uint256 amount1Desired,\r\n        uint256 amount0Min,\r\n        uint256 amount1Min,\r\n        uint256 poolId\r\n    ) external {\r\n        require(\r\n            IStakingRewards(stakingRewards).getPool(poolId).stakingToken ==\r\n                vaultAddress,\r\n            \"Incorrect pool id\"\r\n        );\r\n\r\n        uint256 share = _deposit(\r\n            vaultAddress,\r\n            amount0Desired,\r\n            amount1Desired,\r\n            amount0Min,\r\n            amount1Min,\r\n            address(this)\r\n        );\r\n\r\n        SafeERC20.safeApprove(IERC20(vaultAddress), stakingRewards, share);\r\n        IStakingRewards(stakingRewards).stakeFor(msg.sender, share, poolId);\r\n    }\r\n\r\n    function vaultDetailsByAddress(address vault)\r\n        external\r\n        view\r\n        returns (IMultiPositionManager.VaultDetails memory details)\r\n    {\r\n        IMultiPositionManager vaultInstance = IMultiPositionManager(vault);\r\n\r\n        IERC20Metadata token0 = IERC20Metadata(vaultInstance.token0());\r\n        IERC20Metadata token1 = IERC20Metadata(vaultInstance.token1());\r\n\r\n        // Get total amounts, excluding fees\r\n        (uint256 bal0, uint256 bal1) = vaultInstance.getTotalAmounts();\r\n\r\n        return\r\n            IMultiPositionManager.VaultDetails(\r\n                IVaultRegistry(vaultRegistry).beaconTypes(vault),\r\n                vaultInstance.token0(),\r\n                vaultInstance.token1(),\r\n                IERC20Metadata(vault).name(),\r\n                IERC20Metadata(vault).symbol(),\r\n                IERC20Metadata(vault).decimals(),\r\n                token0.name(),\r\n                token1.name(),\r\n                token0.symbol(),\r\n                token1.symbol(),\r\n                token0.decimals(),\r\n                token1.decimals(),\r\n                IUniswapV3Pool(vaultInstance.pool()).fee(),\r\n                vaultInstance.totalSupply(),\r\n                bal0,\r\n                bal1\r\n            );\r\n    }\r\n\r\n    function vaultBalancesByAddressWithFees(address vault)\r\n        external\r\n        returns (IMultiPositionManager.VaultBalance memory balances)\r\n    {\r\n        IMultiPositionManager vaultInstance = IMultiPositionManager(vault);\r\n        vaultInstance.poke();\r\n        (uint256 bal0, uint256 bal1) = vaultInstance.getTotalAmounts();\r\n\r\n        return IMultiPositionManager.VaultBalance(bal0, bal1);\r\n    }\r\n\r\n    function createVaultAndStrategy(\r\n        address strategyCreator,\r\n        string calldata name,\r\n        string calldata execBundle,\r\n        uint128 maxGasCost,\r\n        uint128 maxGasPerAction,\r\n        bytes calldata params,\r\n        string calldata beaconName,\r\n        string memory payloadIpfs\r\n    ) external returns (uint256 tokenId, address newVault) {\r\n        tokenId = IStrategyRegistry(strategyRegistry).createStrategy(\r\n            strategyCreator,\r\n            name,\r\n            execBundle,\r\n            maxGasCost,\r\n            maxGasPerAction\r\n        );\r\n        newVault = IVaultRegistry(vaultRegistry).createVault(\r\n            params,\r\n            tokenId,\r\n            beaconName,\r\n            payloadIpfs\r\n        );\r\n    }\r\n\r\n    // Public Functions\r\n\r\n    /// @dev Get the strategies by creator\r\n    /// @param creator The creator of the strategies\r\n    /// @return The List of strategies created by the creator\r\n    function strategiesByCreator(address creator)\r\n        public\r\n        view\r\n        returns (IStrategyRegistry.RegisteredStrategy[] memory)\r\n    {\r\n        // Find the userse balance\r\n        uint256 strategyBalance = IStrategyRegistry(strategyRegistry)\r\n            .balanceOf(creator);\r\n\r\n        // Create an array to hold the strategy details\r\n        // which is the same length of the balance of the registered strategies\r\n        IStrategyRegistry.RegisteredStrategy[]\r\n            memory userStrategies = new IStrategyRegistry.RegisteredStrategy[](\r\n                strategyBalance\r\n            );\r\n\r\n        uint256 tokenId;\r\n        // Iterate through the user's strategies and fill the array\r\n        for (uint256 i; i != strategyBalance; ++i) {\r\n            // Get token id of a strategy based on the owner and the index of the strategy\r\n            tokenId = IStrategyRegistry(strategyRegistry).tokenOfOwnerByIndex(\r\n                creator,\r\n                i\r\n            );\r\n\r\n            // Using the tokenId, get the strategy details from the strategy registry\r\n            IStrategyRegistry.RegisteredStrategy\r\n                memory strategy = IStrategyRegistry(strategyRegistry)\r\n                    .getRegisteredStrategy(tokenId);\r\n\r\n            // Add the strategy to the array based on the loop index\r\n            userStrategies[i] = strategy;\r\n        }\r\n\r\n        // Return the array of strategies\r\n        return userStrategies;\r\n    }\r\n\r\n    /// @dev Get the vaults using a given strategy\r\n    /// @param strategyId The strategyId (ERC-721 tokenId)\r\n    /// @return The List of vault details using the strategy\r\n    function vaultsByStrategy(uint256 strategyId)\r\n        public\r\n        view\r\n        returns (IVaultRegistry.VaultData[] memory)\r\n    {\r\n        // Get the amount of vaults using the strategy\r\n        uint256 vaultCount = IVaultRegistry(vaultRegistry)\r\n            .getVaultCountByStrategyId(strategyId);\r\n\r\n        // Create an array to hold the vault details\r\n        IVaultRegistry.VaultData[]\r\n            memory strategyVaults = new IVaultRegistry.VaultData[](vaultCount);\r\n\r\n        IVaultRegistry.VaultData memory thisData;\r\n        // Iterate through the vaults and fill the array\r\n        for (uint256 i; i != vaultCount; ++i) {\r\n            // Retrieve the VaultData struct using the\r\n            // strategyId and the index of the vault for the strategy\r\n            thisData = IVaultRegistry(vaultRegistry)\r\n                .getVaultByStrategyAndIndex(strategyId, i);\r\n\r\n            // Add the vault to the array based on the loop index\r\n            strategyVaults[i] = thisData;\r\n        }\r\n\r\n        // Return the array of vaultData\r\n        return strategyVaults;\r\n    }\r\n\r\n    // Internal Functions\r\n\r\n    /// @dev Deposits tokens in proportion to the vault's current holdings.\r\n    /// @dev These tokens sit in the vault and are not used for liquidity on\r\n    ///      Uniswap until the next rebalance.\r\n    /// @param vaultAddress The address of the vault to deposit to\r\n    /// @param amount0Desired Max amount of token0 to deposit\r\n    /// @param amount1Desired Max amount of token1 to deposit\r\n    /// @param amount0Min Revert if resulting `amount0` is less than this\r\n    /// @param amount1Min Revert if resulting `amount1` is less than this\r\n    /// @param to Recipient of shares\r\n    /// @return shares Number of shares minted\r\n    function _deposit(\r\n        address vaultAddress,\r\n        uint256 amount0Desired,\r\n        uint256 amount1Desired,\r\n        uint256 amount0Min,\r\n        uint256 amount1Min,\r\n        address to\r\n    ) internal returns (uint256) {\r\n        IMultiPositionManager vaultInstance = IMultiPositionManager(\r\n            vaultAddress\r\n        );\r\n        IERC20Metadata token0 = IERC20Metadata(vaultInstance.token0());\r\n        IERC20Metadata token1 = IERC20Metadata(vaultInstance.token1());\r\n        if (amount0Desired > 0)\r\n            token0.transferFrom(msg.sender, address(this), amount0Desired);\r\n        if (amount1Desired > 0)\r\n            token1.transferFrom(msg.sender, address(this), amount1Desired);\r\n        token0.approve(vaultAddress, amount0Desired);\r\n        token1.approve(vaultAddress, amount1Desired);\r\n\r\n        (uint256 share, uint256 amount0, uint256 amount1) = vaultInstance\r\n            .deposit(\r\n                amount0Desired,\r\n                amount1Desired,\r\n                amount0Min,\r\n                amount1Min,\r\n                to\r\n            );\r\n\r\n        if (amount0Desired > amount0) {\r\n            token0.transfer(msg.sender, amount0Desired - amount0);\r\n        }\r\n        if (amount1Desired > amount1) {\r\n            token1.transfer(msg.sender, amount1Desired - amount1);\r\n        }\r\n\r\n        return share;\r\n    }\r\n\r\n    function _authorizeUpgrade(address) internal override onlyOwner {}\r\n}\r\n"
    },
    "contracts/interfaces/ISteerPeriphery.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\nimport \"./IVaultRegistry.sol\";\r\nimport \"./IStrategyRegistry.sol\";\r\nimport \"./IMultiPositionManager.sol\";\r\n\r\ninterface ISteerPeriphery {\r\n    function vaultsByStrategy(uint256 _strategyId)\r\n        external\r\n        view\r\n        returns (IVaultRegistry.VaultData[] memory);\r\n\r\n    function strategiesByCreator(address _address)\r\n        external\r\n        view\r\n        returns (IStrategyRegistry.RegisteredStrategy[] memory);\r\n\r\n    function deposit(\r\n        address _vaultAddress,\r\n        uint256 amount0Desired,\r\n        uint256 amount1Desired,\r\n        uint256 amount0Min,\r\n        uint256 amount1Min,\r\n        address to\r\n    ) external;\r\n\r\n    function vaultDetailsByAddress(address _vault)\r\n        external\r\n        view\r\n        returns (IMultiPositionManager.VaultDetails memory details);\r\n\r\n    function vaultBalancesByAddressWithFees(address _vault)\r\n        external\r\n        returns (IMultiPositionManager.VaultBalance memory balances);\r\n\r\n    function createVaultAndStrategy(\r\n        address strategyCreator,\r\n        string memory name,\r\n        string memory execBundle,\r\n        uint128 maxGasCost,\r\n        uint128 maxGasPerAction,\r\n        bytes memory _params,\r\n        string memory _beaconName,\r\n        string memory _payloadIpfs\r\n    ) external returns (uint256 tokenId, address newVault);\r\n}\r\n"
    },
    "contracts/interfaces/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\ninterface IStakingRewards {\r\n    // Structs\r\n\r\n    /// stakingToken: Address of the token that will be staked\r\n    /// rewardToken: Address of the token that will be given as reward\r\n    /// rewardRate: Rate at which the rewards will be calculated,\r\n    ///             reward rate will be multiplied by 100 for decimal precision,\r\n    ///             for e.g. 6000 means 60%/year, 1000 means 10%/year\r\n    /// start: Start time of the staking pool\r\n    /// end: Ending time for the staking pool\r\n    struct Pool {\r\n        address stakingToken;\r\n        address rewardToken;\r\n        uint256 rewardRate;\r\n        uint256 totalAmount;\r\n        uint256 start;\r\n        uint256 end;\r\n    }\r\n\r\n    // Events\r\n\r\n    event Staked(address indexed user, uint256 amount, uint256 poolId);\r\n    event Withdrawn(address indexed user, uint256 amount, uint256 poolId);\r\n    event RewardPaid(address indexed user, uint256 poolId, uint256 reward);\r\n    event RewardsDeposited(address depositor, uint256 poolId, uint256 amount);\r\n    event RewardsWithdrawn(uint256 amount, uint256 poolId);\r\n\r\n    // Functions\r\n\r\n    function createPool(\r\n        address stakingToken,\r\n        address rewardToken,\r\n        uint256 rewardRate,\r\n        uint256 start,\r\n        uint256 end\r\n    ) external;\r\n\r\n    function stake(uint256 amount, uint256 poolId) external;\r\n\r\n    function stakeFor(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 poolId\r\n    ) external;\r\n\r\n    function unstake(uint256 poolId) external;\r\n\r\n    function depositRewards(uint256 poolId, uint256 amount) external;\r\n\r\n    function withdrawRewards(\r\n        uint256 poolId,\r\n        uint256 amount,\r\n        address receiver\r\n    ) external;\r\n\r\n    function toggleStakingInPool(uint256 poolId, bool pause) external;\r\n\r\n    function claimPendingRewards(uint256 poolId) external;\r\n\r\n    function getRewardsForAPool(address account, uint256 poolId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getPools()\r\n        external\r\n        view\r\n        returns (Pool[] memory pools, string[] memory symbols);\r\n\r\n    function getPool(uint256 poolId) external view returns (Pool memory pool);\r\n}\r\n"
    },
    "contracts/interfaces/IMultiPositionManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.10;\r\npragma abicoder v2;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\r\n\r\ninterface IMultiPositionManager is IERC20 {\r\n    struct VaultDetails {\r\n        string vaultType;\r\n        address token0;\r\n        address token1;\r\n        string name;\r\n        string symbol;\r\n        uint256 decimals;\r\n        string token0Name;\r\n        string token1Name;\r\n        string token0Symbol;\r\n        string token1Symbol;\r\n        uint256 token0Decimals;\r\n        uint256 token1Decimals;\r\n        uint256 feeTier;\r\n        uint256 totalLPTokensIssued;\r\n        uint256 token0Balance;\r\n        uint256 token1Balance;\r\n    }\r\n\r\n    struct VaultBalance {\r\n        uint256 amountToken0;\r\n        uint256 amountToken1;\r\n    }\r\n\r\n    struct LiquidityPositions {\r\n        int24[] lowerTick;\r\n        int24[] upperTick;\r\n        uint16[] relativeWeight;\r\n    }\r\n\r\n    /**\r\n     * @dev initializes vault\r\n     * param _orchestrator is address of orchestrator, which has permission to call update.\r\n     * param _params is all other parameters this vault will use.\r\n     * param _tokenName is the name of the LPT of this vault.\r\n     * param _symbol is the symbol of the LPT of this vault.\r\n     * param token0 is address of token0\r\n     * param token1 is address of token1\r\n     * param _FEE is pool fee, how much is charged for a swap\r\n     */\r\n    function initialize(\r\n        address _orchestrator,\r\n        address _steer,\r\n        bytes memory _params\r\n    ) external;\r\n\r\n    ///\r\n    /// @dev Deposits tokens in proportion to the vault's current holdings.\r\n    /// @dev These tokens sit in the vault and are not used for liquidity on\r\n    /// Uniswap until the next rebalance.\r\n    /// @param amount0Desired Max amount of token0 to deposit\r\n    /// @param amount1Desired Max amount of token1 to deposit\r\n    /// @param amount0Min Revert if resulting `amount0` is less than this\r\n    /// @param amount1Min Revert if resulting `amount1` is less than this\r\n    /// @param to Recipient of shares\r\n    /// @return shares Number of shares minted\r\n    /// @return amount0 Amount of token0 deposited\r\n    /// @return amount1 Amount of token1 deposited\r\n    ///\r\n    function deposit(\r\n        uint256 amount0Desired,\r\n        uint256 amount1Desired,\r\n        uint256 amount0Min,\r\n        uint256 amount1Min,\r\n        address to\r\n    )\r\n        external\r\n        returns (\r\n            uint256 shares,\r\n            uint256 amount0,\r\n            uint256 amount1\r\n        );\r\n\r\n    /**\r\n     * @dev burns each vault position which contains liquidity, updating fees owed to that position.\r\n     * @dev call this before calling getTotalAmounts if total amounts must include fees. There's a function in the periphery to do so through a static call.\r\n     */\r\n    function poke() external;\r\n\r\n    /**\r\n     * @dev Withdraws tokens in proportion to the vault's holdings.\r\n     * @param shares Shares burned by sender\r\n     * @param amount0Min Revert if resulting `amount0` is smaller than this\r\n     * @param amount1Min Revert if resulting `amount1` is smaller than this\r\n     * @param to Recipient of tokens\r\n     * @return amount0 Amount of token0 sent to recipient\r\n     * @return amount1 Amount of token1 sent to recipient\r\n     */\r\n    function withdraw(\r\n        uint256 shares,\r\n        uint256 amount0Min,\r\n        uint256 amount1Min,\r\n        address to\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    /**\r\n     * @dev Internal function to pull funds from pool, update positions if necessary, then deposit funds into pool.\r\n     * @dev reverts if it does not have any liquidity.\r\n\r\n     * @dev newPositions requirements:\r\n     * Each lowerTick must be lower than its corresponding upperTick\r\n     * Each lowerTick must be greater than or equal to the tick min (-887272)\r\n     * Each upperTick must be less than or equal to the tick max (887272)\r\n     * All lowerTicks and upperTicks must be divisible by the pool tickSpacing--\r\n        A 0.05% fee pool has tick spacing of 10, 0.3% has tick spacing 60. and 1% has tick spacing 200.)\r\n     */\r\n    function tend(\r\n        LiquidityPositions memory newPositions,\r\n        int256 swapAmount,\r\n        uint160 sqrtPriceLimitX96\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Calculates the vault's total holdings of token0 and token1 - in\r\n     *      other words, how much of each token the vault would hold if it withdrew\r\n     *      all its liquidity from Uniswap.\r\n     * @dev this function DOES NOT include fees. To include fees, first poke() and then call getTotalAmounts. There's a function inside the periphery to do so.\r\n     */\r\n    function getTotalAmounts()\r\n        external\r\n        view\r\n        returns (uint256 total0, uint256 total1);\r\n\r\n    //Tokens\r\n    function vaultRegistry() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function accruedSteerFees0() external view returns (uint256);\r\n\r\n    function accruedSteerFees1() external view returns (uint256);\r\n\r\n    function accruedStrategistFees0() external view returns (uint256);\r\n\r\n    function accruedStrategistFees1() external view returns (uint256);\r\n\r\n    function maxTotalSupply() external view returns (uint256);\r\n\r\n    function pool() external view returns (IUniswapV3Pool);\r\n\r\n    /**\r\n     * @dev Used to collect accumulated protocol fees.\r\n     */\r\n    function steerCollectFees(\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address to\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Used to collect accumulated protocol fees.\r\n     */\r\n    function strategistCollectFees(\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address to\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Removes tokens accidentally sent to this vault.\r\n     */\r\n    function sweep(\r\n        address token,\r\n        uint256 amount,\r\n        address to\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Used to change deposit cap for a guarded launch or to ensure\r\n     * vault doesn't grow too large relative to the pool. Cap is on total\r\n     * supply rather than amounts of token0 and token1 as those amounts\r\n     * fluctuate naturally over time.\r\n     */\r\n    function setMaxTotalSupply(uint256 _maxTotalSupply) external;\r\n\r\n    /**\r\n     * @dev Used to change the MaxTickChange and twapinterval used when checking for flash\r\n     * loans, by default set to 500 ticks and 45 seconds, respectively\r\n     */\r\n    function setTWAPnums(int24 newMax, uint32 newInterval) external;\r\n\r\n    /**\r\n     * @dev Removes liquidity in case of emergency.\r\n     */\r\n    function emergencyBurn(\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 liquidity\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n}\r\n"
    },
    "contracts/interfaces/IBaseDeposit.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.7.6;\r\n\r\n/// @dev Interface for supporting depositing 2 assets via periphery\r\ninterface IBaseDeposit {\r\n    ///\r\n    /// @dev Deposits tokens in proportion to the vault's current holdings.\r\n    /// @dev These tokens sit in the vault and are not used for liquidity on\r\n    /// Uniswap until the next rebalance.\r\n    /// @param amount0Desired Max amount of token0 to deposit\r\n    /// @param amount1Desired Max amount of token1 to deposit\r\n    /// @param amount0Min Revert if resulting `amount0` is less than this\r\n    /// @param amount1Min Revert if resulting `amount1` is less than this\r\n    /// @param to Recipient of shares\r\n    /// @return shares Number of shares minted\r\n    /// @return amount0 Amount of token0 deposited\r\n    /// @return amount1 Amount of token1 deposited\r\n    ///\r\n    function deposit(\r\n        uint256 amount0Desired,\r\n        uint256 amount1Desired,\r\n        uint256 amount0Min,\r\n        uint256 amount1Min,\r\n        address to\r\n    )\r\n        external\r\n        returns (\r\n            uint256 shares,\r\n            uint256 amount0,\r\n            uint256 amount1\r\n        );\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165CheckerUpgradeable {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165Upgradeable).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165Upgradeable.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n    /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n    /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    function uniswapV3MintCallback(\n        uint256 amount0Owed,\n        uint256 amount1Owed,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/PositionKey.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nlibrary PositionKey {\n    /// @dev Returns the key of the position in the core library\n    function compute(\n        address owner,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(owner, tickLower, tickUpper));\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/LiquidityAmounts.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';\n\n/// @title Liquidity amount functions\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary LiquidityAmounts {\n    /// @notice Downcasts uint256 to uint128\n    /// @param x The uint258 to be downcasted\n    /// @return y The passed value, downcasted to uint128\n    function toUint128(uint256 x) private pure returns (uint128 y) {\n        require((y = uint128(x)) == x);\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount0 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount0(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount1 The amount1 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount1(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\n    }\n\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount of token0 being sent in\n    /// @param amount1 The amount of token1 being sent in\n    /// @return liquidity The maximum amount of liquidity received\n    function getLiquidityForAmounts(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        } else {\n            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n        }\n    }\n\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    function getAmount0ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return\n            FullMath.mulDiv(\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\n                sqrtRatioBX96 - sqrtRatioAX96,\n                sqrtRatioBX96\n            ) / sqrtRatioAX96;\n    }\n\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount1 The amount of token1\n    function getAmount1ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n        } else {\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0 <0.9.0;\r\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = denominator & (~denominator + 1);\r\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/SqrtPriceMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport './LowGasSafeMath.sol';\nimport './SafeCast.sol';\n\nimport './FullMath.sol';\nimport './UnsafeMath.sol';\nimport './FixedPoint96.sol';\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /// @notice Gets the next sqrt price given a delta of token0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of token0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            uint256 product;\n            if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n                uint256 denominator = numerator1 + product;\n                if (denominator >= numerator1)\n                    // always fits in 160 bits\n                    return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n            }\n\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));\n        } else {\n            uint256 product;\n            // if the product overflows, we know the denominator underflows\n            // in addition, we must check that the denominator does not underflow\n            require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n            uint256 denominator = numerator1 - product;\n            return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of token1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of token1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient =\n                (\n                    amount <= type(uint160).max\n                        ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                        : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n                );\n\n            return uint256(sqrtPX96).add(quotient).toUint160();\n        } else {\n            uint256 quotient =\n                (\n                    amount <= type(uint160).max\n                        ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                        : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n                );\n\n            require(sqrtPX96 > quotient);\n            // always fits 160 bits\n            return uint160(sqrtPX96 - quotient);\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of token0, or token1, is being swapped in\n    /// @param zeroForOne Whether the amount in is token0 or token1\n    /// @return sqrtQX96 The price after adding the input amount to token0 or token1\n    function getNextSqrtPriceFromInput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountIn,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we don't pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n                : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of token0, or token1, is being swapped out\n    /// @param zeroForOne Whether the amount out is token0 or token1\n    /// @return sqrtQX96 The price after removing the output amount of token0 or token1\n    function getNextSqrtPriceFromOutput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountOut,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n                : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount0) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n        require(sqrtRatioAX96 > 0);\n\n        return\n            roundUp\n                ? UnsafeMath.divRoundingUp(\n                    FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),\n                    sqrtRatioAX96\n                )\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return\n            roundUp\n                ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\n                : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Helper that gets signed token0 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount0) {\n        return\n            liquidity < 0\n                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n    }\n\n    /// @notice Helper that gets signed token1 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount1) {\n        return\n            liquidity < 0\n                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.9.0;\r\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(887272), 'T');\r\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "contracts/StrategyRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"./interfaces/IStrategyRegistry.sol\";\r\n\r\n// Proxy Support\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\n// Access Control\r\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\r\n\r\n// 721 Support\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol\";\r\n\r\n/// @title A registry for strategies\r\n/// @author Steer Protocol\r\n/// @dev All strategies are registered through this contract.\r\n/// @dev This is where strategy bundles are stored as well as the offline data needed to decode parameters stored on a vault.\r\ncontract StrategyRegistry is\r\n    Initializable,\r\n    ERC721Upgradeable,\r\n    ERC721URIStorageUpgradeable,\r\n    ERC721EnumerableUpgradeable,\r\n    ERC721PausableUpgradeable,\r\n    AccessControlUpgradeable,\r\n    UUPSUpgradeable,\r\n    OwnableUpgradeable\r\n{\r\n    // Library setup\r\n    using CountersUpgradeable for CountersUpgradeable.Counter;\r\n\r\n    string internal _baseTokenURI;\r\n\r\n    // Mapping for pulling strategy details from the registry by the hash of the ipfs cid\r\n    //    CID => RegisteredStrategy\r\n    mapping(string => IStrategyRegistry.RegisteredStrategy) public strategies;\r\n\r\n    // Mapping for pulling strategy ipfs cid by the ERC721 tokenId associated\r\n    //   ERC721 tokenId => CID\r\n    mapping(uint256 => string) public tokenIdToExecBundle;\r\n\r\n    // Counter to keep track of totalSupply\r\n    CountersUpgradeable.Counter public _tokenIdTracker;\r\n\r\n    // Set up roles\r\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\r\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\r\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\r\n\r\n    // Gas configuration limits\r\n    uint256 public maxMaxGasPerAction; // Max allowable maxGasPerAction. Attempting to set a maxGasPerAction higher than this will revert.\r\n\r\n    // Misc constants\r\n    bytes32 constant hashedEmptyString = keccak256(\"\");\r\n\r\n    event StrategyCreated(\r\n        address indexed owner,\r\n        uint256 indexed tokenId,\r\n        string name //IPFS identifier of execution bundle\r\n    );\r\n\r\n    function initialize(string memory registry) public initializer {\r\n        // Initializers\r\n        __Context_init();\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n        __ERC165_init();\r\n        __AccessControl_init();\r\n        __ERC721_init(\"Steer Strategy\", \"STR_SRTGY\");\r\n        __ERC721Enumerable_init();\r\n        __Pausable_init();\r\n        __ERC721Pausable_init();\r\n        __ERC721URIStorage_init();\r\n\r\n        // Assign roles\r\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\r\n        _setupRole(MINTER_ROLE, _msgSender());\r\n        _setupRole(PAUSER_ROLE, _msgSender());\r\n        _setupRole(GOVERNANCE_ROLE, _msgSender());\r\n\r\n        // Setup the registry base url for the offchain protocol\r\n        // this is used to create namespaced networks\r\n        _baseTokenURI = registry;\r\n        maxMaxGasPerAction = 15000000; // 15 million by default\r\n    }\r\n\r\n    /// @dev Create NFT for execution bundle\r\n    /// @param strategyName The name of the strategy.\r\n    /// @param execBundle The IPFS reference of the execution bundle.\r\n    /// @param maxGasCost The maximum gas cost of the strategy.\r\n    /// @param maxGasPerAction The maximum gas per action of the strategy, in terms of wei / gas.\r\n    /// @return newStrategyTokenId as the token id of the new NFT.\r\n    function createStrategy(\r\n        address strategyCreator,\r\n        string calldata strategyName,\r\n        string calldata execBundle,\r\n        uint128 maxGasCost,\r\n        uint128 maxGasPerAction\r\n    ) external returns (uint256 newStrategyTokenId) {\r\n        // Check if the strategy is already registered\r\n        // This occurs when the bundle has the same CID as a previously registered bundle\r\n        require(\r\n            keccak256(abi.encodePacked(strategies[execBundle].execBundle)) ==\r\n                hashedEmptyString,\r\n            \"Strategy already exists\"\r\n        );\r\n\r\n        // Validate gas config\r\n        require(\r\n            maxGasPerAction <= maxMaxGasPerAction,\r\n            \"maxGasPerAction too high\"\r\n        );\r\n\r\n        // Mint a new token to the current sender\r\n        newStrategyTokenId = mint(strategyCreator, execBundle);\r\n\r\n        // Utilizing the CID of the bundle we map the CID to a struct of RegisteredStrategy\r\n        // We use the bundle hash instead of the token ID because this is helpful for the offchain protocol\r\n        strategies[execBundle] = IStrategyRegistry.RegisteredStrategy(\r\n            newStrategyTokenId,\r\n            strategyName,\r\n            strategyCreator,\r\n            execBundle,\r\n            maxGasCost,\r\n            maxGasPerAction\r\n        );\r\n\r\n        // To help with enumeration we also map the token ID to the CID\r\n        tokenIdToExecBundle[newStrategyTokenId] = execBundle;\r\n\r\n        // Emit StrategyCreated event once a strategy is created\r\n        emit StrategyCreated(\r\n            strategyCreator,\r\n            newStrategyTokenId,\r\n            strategyName\r\n        );\r\n    }\r\n\r\n    /// @dev Get the base URI\r\n    /// @return The base URI of the registry\r\n    /// @dev This is an internal function\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return _baseTokenURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the base URI\r\n     * @return The base URI of the registry\r\n     */\r\n    function baseURI() external view returns (string memory) {\r\n        return _baseURI();\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a new token for `to`. Its token ID will be automatically\r\n     * assigned (and available on the emitted {IERC721-Transfer} event), and the token\r\n     * URI autogenerated based on the base URI passed at construction.\r\n     *\r\n     * See {ERC721-_mint}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the `MINTER_ROLE`.\r\n     */\r\n    function mint(address recipient, string calldata bundle)\r\n        private\r\n        returns (uint256)\r\n    {\r\n        uint256 newStrategyId = _tokenIdTracker.current();\r\n        _mint(recipient, newStrategyId);\r\n        _setTokenURI(newStrategyId, bundle);\r\n        _tokenIdTracker.increment();\r\n        return newStrategyId;\r\n    }\r\n\r\n    /**\r\n     * @dev Pauses all token transfers.\r\n     *\r\n     * See {ERC721Pausable} and {Pausable-_pause}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the `PAUSER_ROLE`.\r\n     */\r\n    function pause() public {\r\n        require(\r\n            hasRole(PAUSER_ROLE, _msgSender()),\r\n            \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\"\r\n        );\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpauses all token transfers.\r\n     *\r\n     * See {ERC721Pausable} and {Pausable-_unpause}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the `PAUSER_ROLE`.\r\n     */\r\n    function unpause() public {\r\n        require(\r\n            hasRole(PAUSER_ROLE, _msgSender()),\r\n            \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\"\r\n        );\r\n        _unpause();\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    )\r\n        internal\r\n        override(\r\n            ERC721Upgradeable,\r\n            ERC721EnumerableUpgradeable,\r\n            ERC721PausableUpgradeable\r\n        )\r\n    {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override(\r\n            AccessControlUpgradeable,\r\n            ERC721Upgradeable,\r\n            ERC721EnumerableUpgradeable\r\n        )\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        override(ERC721URIStorageUpgradeable, ERC721Upgradeable)\r\n        returns (string memory)\r\n    {\r\n        return super.tokenURI(tokenId);\r\n    }\r\n\r\n    function _burn(uint256 tokenId)\r\n        internal\r\n        override(ERC721URIStorageUpgradeable, ERC721Upgradeable)\r\n    {\r\n        super._burn(tokenId);\r\n    }\r\n\r\n    function burn(uint256 tokenId) external {\r\n        _burn(tokenId);\r\n    }\r\n\r\n    function _authorizeUpgrade(address) internal override onlyOwner {}\r\n\r\n    /// @dev Get the strategy details by tokenId\r\n    /// @param tokenId The token id of the strategy\r\n    /// @return The details of the strategy\r\n    function getRegisteredStrategy(uint256 tokenId)\r\n        public\r\n        view\r\n        returns (IStrategyRegistry.RegisteredStrategy memory)\r\n    {\r\n        return strategies[tokenIdToExecBundle[tokenId]];\r\n    }\r\n\r\n    /// @dev Set the gas parameters for a given strategy\r\n    /// @param _tokenId The token id of the strategy\r\n    /// @param _maxGasCost The maximum gas cost of the strategy\r\n    /// @param _maxGasPerAction The maximum gas per action of the strategy\r\n    function setGasParameters(\r\n        uint256 _tokenId,\r\n        uint128 _maxGasCost,\r\n        uint128 _maxGasPerAction\r\n    ) external {\r\n        // Only the owner of the strategy is the only one who can set the gas parameters\r\n        require(\r\n            msg.sender == ownerOf(_tokenId),\r\n            \"Only strategy owner can set gas parameters\"\r\n        );\r\n\r\n        // Validate gas config\r\n        require(\r\n            _maxGasPerAction <= maxMaxGasPerAction,\r\n            \"maxGasPerAction too high\"\r\n        );\r\n\r\n        // Retrieve the current strategy details\r\n        IStrategyRegistry.RegisteredStrategy memory strategy = strategies[\r\n            tokenIdToExecBundle[_tokenId]\r\n        ];\r\n\r\n        // Set the gas parameters\r\n        strategy.maxGasCost = _maxGasCost;\r\n        strategy.maxGasPerAction = _maxGasPerAction;\r\n\r\n        // Update the strategy details with the mutated struct\r\n        strategies[tokenIdToExecBundle[_tokenId]] = strategy;\r\n    }\r\n\r\n    function setMaxMaxGasPerAction(uint256 _maxMaxGasPerAction)\r\n        external\r\n        onlyOwner\r\n    {\r\n        maxMaxGasPerAction = _maxMaxGasPerAction;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorageUpgradeable is Initializable, ERC721Upgradeable {\n    function __ERC721URIStorage_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721URIStorage_init_unchained();\n    }\n\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    using StringsUpgradeable for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721Enumerable_init_unchained();\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC721PausableUpgradeable is Initializable, ERC721Upgradeable, PausableUpgradeable {\n    function __ERC721Pausable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __Pausable_init_unchained();\n        __ERC721Pausable_init_unchained();\n    }\n\n    function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/IGovernorTimelockUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/IGovernorTimelock.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IGovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of the {IGovernor} for timelock supporting modules.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorTimelockUpgradeable is Initializable, IGovernorUpgradeable {\n    function __IGovernorTimelock_init() internal onlyInitializing {\n        __IGovernor_init_unchained();\n        __IGovernorTimelock_init_unchained();\n    }\n\n    function __IGovernorTimelock_init_unchained() internal onlyInitializing {\n    }\n    event ProposalQueued(uint256 proposalId, uint256 eta);\n\n    function timelock() public view virtual returns (address);\n\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256);\n\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/IGovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/IGovernor.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Interface of the {Governor} core.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorUpgradeable is Initializable, IERC165Upgradeable {\n    function __IGovernor_init() internal onlyInitializing {\n        __IGovernor_init_unchained();\n    }\n\n    function __IGovernor_init_unchained() internal onlyInitializing {\n    }\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast.\n     *\n     * Note: `support` values should be seen as buckets. There interpretation depends on the voting module used.\n     */\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\n     */\n    function name() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\n     */\n    function version() public view virtual returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(uint256 proposalId) public view virtual returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev Block number used to retrieve user's votes and quorum. As per Compound's Comp and OpenZeppelin's\n     * ERC20Votes, the snapshot is performed at the end of this block. Hence, voting for this proposal starts at the\n     * beginning of the following block.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Block number at which votes close. Votes close at the end of this block, so it is possible to cast a vote\n     * during this block.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, in number of block, between the proposal is created and the vote starts. This can be increassed to\n     * leave time for users to buy voting power, of delegate it, before the voting of a proposal starts.\n     */\n    function votingDelay() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, in number of blocks, between the vote start and vote ends.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * Note: The `blockNumber` parameter corresponds to the snaphot used for counting vote. This allows to scale the\n     * quroum depending on values such as the totalSupply of a token at this block (see {ERC20Votes}).\n     */\n    function quorum(uint256 blockNumber) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `blockNumber`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account, uint256 blockNumber) public view virtual returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns weither `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends\n     * {IGovernor-votingPeriod} blocks after the voting starts.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the user cryptographic signature.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/compatibility/IGovernorCompatibilityBravoUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/compatibility/IGovernorCompatibilityBravo.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IGovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Interface extension that adds missing functions to the {Governor} core to provide `GovernorBravo` compatibility.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorCompatibilityBravoUpgradeable is Initializable, IGovernorUpgradeable {\n    function __IGovernorCompatibilityBravo_init() internal onlyInitializing {\n        __IGovernor_init_unchained();\n        __IGovernorCompatibilityBravo_init_unchained();\n    }\n\n    function __IGovernorCompatibilityBravo_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Proposal structure from Compound Governor Bravo. Not actually used by the compatibility layer, as\n     * {{proposal}} returns a very different structure.\n     */\n    struct Proposal {\n        uint256 id;\n        address proposer;\n        uint256 eta;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 abstainVotes;\n        bool canceled;\n        bool executed;\n        mapping(address => Receipt) receipts;\n    }\n\n    /**\n     * @dev Receipt structure from Compound Governor Bravo\n     */\n    struct Receipt {\n        bool hasVoted;\n        uint8 support;\n        uint96 votes;\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface.\n     */\n    function quorumVotes() public view virtual returns (uint256);\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The official record of all proposals ever proposed\"_.\n     */\n    function proposals(uint256)\n        public\n        view\n        virtual\n        returns (\n            uint256 id,\n            address proposer,\n            uint256 eta,\n            uint256 startBlock,\n            uint256 endBlock,\n            uint256 forVotes,\n            uint256 againstVotes,\n            uint256 abstainVotes,\n            bool canceled,\n            bool executed\n        );\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Function used to propose a new proposal\"_.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256);\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Queues a proposal of state succeeded\"_.\n     */\n    function queue(uint256 proposalId) public virtual;\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Executes a queued proposal if eta has passed\"_.\n     */\n    function execute(uint256 proposalId) public payable virtual;\n\n    /**\n     * @dev Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold.\n     */\n    function cancel(uint256 proposalId) public virtual;\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Gets actions of a proposal\"_.\n     */\n    function getActions(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        );\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Gets the receipt for a voter on a given proposal\"_.\n     */\n    function getReceipt(uint256 proposalId, address voter) public view virtual returns (Receipt memory);\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.4.2) (governance/compatibility/GovernorCompatibilityBravo.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/CountersUpgradeable.sol\";\nimport \"../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../extensions/IGovernorTimelockUpgradeable.sol\";\nimport \"../GovernorUpgradeable.sol\";\nimport \"./IGovernorCompatibilityBravoUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Compatibility layer that implements GovernorBravo compatibility on to of {Governor}.\n *\n * This compatibility layer includes a voting system and requires a {IGovernorTimelock} compatible module to be added\n * through inheritance. It does not include token bindings, not does it include any variable upgrade patterns.\n *\n * NOTE: When using this module, you may need to enable the Solidity optimizer to avoid hitting the contract size limit.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorCompatibilityBravoUpgradeable is Initializable, IGovernorTimelockUpgradeable, IGovernorCompatibilityBravoUpgradeable, GovernorUpgradeable {\n    function __GovernorCompatibilityBravo_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __IGovernor_init_unchained();\n        __IGovernorTimelock_init_unchained();\n        __IGovernorCompatibilityBravo_init_unchained();\n        __GovernorCompatibilityBravo_init_unchained();\n    }\n\n    function __GovernorCompatibilityBravo_init_unchained() internal onlyInitializing {\n    }\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using TimersUpgradeable for TimersUpgradeable.BlockNumber;\n\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalDetails {\n        address proposer;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 abstainVotes;\n        mapping(address => Receipt) receipts;\n        bytes32 descriptionHash;\n    }\n\n    mapping(uint256 => ProposalDetails) private _proposalDetails;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=bravo\";\n    }\n\n    // ============================================== Proposal lifecycle ==============================================\n    /**\n     * @dev See {IGovernor-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override(IGovernorUpgradeable, GovernorUpgradeable) returns (uint256) {\n        _storeProposal(_msgSender(), targets, values, new string[](calldatas.length), calldatas, description);\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        _storeProposal(_msgSender(), targets, values, signatures, calldatas, description);\n        return propose(targets, values, _encodeCalldata(signatures, calldatas), description);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-queue}.\n     */\n    function queue(uint256 proposalId) public virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        queue(\n            details.targets,\n            details.values,\n            _encodeCalldata(details.signatures, details.calldatas),\n            details.descriptionHash\n        );\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-execute}.\n     */\n    function execute(uint256 proposalId) public payable virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        execute(\n            details.targets,\n            details.values,\n            _encodeCalldata(details.signatures, details.calldatas),\n            details.descriptionHash\n        );\n    }\n\n    function cancel(uint256 proposalId) public virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n\n        require(\n            _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),\n            \"GovernorBravo: proposer above threshold\"\n        );\n\n        _cancel(\n            details.targets,\n            details.values,\n            _encodeCalldata(details.signatures, details.calldatas),\n            details.descriptionHash\n        );\n    }\n\n    /**\n     * @dev Encodes calldatas with optional function signature.\n     */\n    function _encodeCalldata(string[] memory signatures, bytes[] memory calldatas)\n        private\n        pure\n        returns (bytes[] memory)\n    {\n        bytes[] memory fullcalldatas = new bytes[](calldatas.length);\n\n        for (uint256 i = 0; i < signatures.length; ++i) {\n            fullcalldatas[i] = bytes(signatures[i]).length == 0\n                ? calldatas[i]\n                : abi.encodePacked(bytes4(keccak256(bytes(signatures[i]))), calldatas[i]);\n        }\n\n        return fullcalldatas;\n    }\n\n    /**\n     * @dev Store proposal metadata for later lookup\n     */\n    function _storeProposal(\n        address proposer,\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) private {\n        bytes32 descriptionHash = keccak256(bytes(description));\n        uint256 proposalId = hashProposal(targets, values, _encodeCalldata(signatures, calldatas), descriptionHash);\n\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        if (details.descriptionHash == bytes32(0)) {\n            details.proposer = proposer;\n            details.targets = targets;\n            details.values = values;\n            details.signatures = signatures;\n            details.calldatas = calldatas;\n            details.descriptionHash = descriptionHash;\n        }\n    }\n\n    // ==================================================== Views =====================================================\n    /**\n     * @dev See {IGovernorCompatibilityBravo-proposals}.\n     */\n    function proposals(uint256 proposalId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint256 id,\n            address proposer,\n            uint256 eta,\n            uint256 startBlock,\n            uint256 endBlock,\n            uint256 forVotes,\n            uint256 againstVotes,\n            uint256 abstainVotes,\n            bool canceled,\n            bool executed\n        )\n    {\n        id = proposalId;\n        eta = proposalEta(proposalId);\n        startBlock = proposalSnapshot(proposalId);\n        endBlock = proposalDeadline(proposalId);\n\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        proposer = details.proposer;\n        forVotes = details.forVotes;\n        againstVotes = details.againstVotes;\n        abstainVotes = details.abstainVotes;\n\n        ProposalState status = state(proposalId);\n        canceled = status == ProposalState.Canceled;\n        executed = status == ProposalState.Executed;\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-getActions}.\n     */\n    function getActions(uint256 proposalId)\n        public\n        view\n        virtual\n        override\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return (details.targets, details.values, details.signatures, details.calldatas);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-getReceipt}.\n     */\n    function getReceipt(uint256 proposalId, address voter) public view virtual override returns (Receipt memory) {\n        return _proposalDetails[proposalId].receipts[voter];\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-quorumVotes}.\n     */\n    function quorumVotes() public view virtual override returns (uint256) {\n        return quorum(block.number - 1);\n    }\n\n    // ==================================================== Voting ====================================================\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalDetails[proposalId].receipts[account].hasVoted;\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}. In this module, only forVotes count toward the quorum.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= details.forVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be scritly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return details.forVotes > details.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows Governor Bravo.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight\n    ) internal virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        Receipt storage receipt = details.receipts[account];\n\n        require(!receipt.hasVoted, \"GovernorCompatibilityBravo: vote already cast\");\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = SafeCastUpgradeable.toUint96(weight);\n\n        if (support == uint8(VoteType.Against)) {\n            details.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            details.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            details.abstainVotes += weight;\n        } else {\n            revert(\"GovernorCompatibilityBravo: invalid vote type\");\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/Governor.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../utils/math/SafeCastUpgradeable.sol\";\nimport \"../utils/AddressUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/TimersUpgradeable.sol\";\nimport \"./IGovernorUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended though various modules.\n *\n * This contract is abstract and requires several function to be implemented in various modules:\n *\n * - A counting module must implement {quorum}, {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {getVotes}\n * - Additionanly, the {votingPeriod} must also be implemented\n *\n * _Available since v4.3._\n */\nabstract contract GovernorUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, EIP712Upgradeable, IGovernorUpgradeable {\n    using SafeCastUpgradeable for uint256;\n    using TimersUpgradeable for TimersUpgradeable.BlockNumber;\n\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    struct ProposalCore {\n        TimersUpgradeable.BlockNumber voteStart;\n        TimersUpgradeable.BlockNumber voteEnd;\n        bool executed;\n        bool canceled;\n    }\n\n    string private _name;\n\n    mapping(uint256 => ProposalCore) private _proposals;\n\n    /**\n     * @dev Restrict access to governor executing address. Some module might override the _executor function to make\n     * sure this modifier is consistant with the execution model.\n     */\n    modifier onlyGovernance() {\n        require(_msgSender() == _executor(), \"Governor: onlyGovernance\");\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    function __Governor_init(string memory name_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __EIP712_init_unchained(name_, version());\n        __IGovernor_init_unchained();\n        __Governor_init_unchained(name_);\n    }\n\n    function __Governor_init_unchained(string memory name_) internal onlyInitializing {\n        _name = name_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        require(_executor() == address(this));\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IGovernorUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IGovernor-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IGovernor-version}.\n     */\n    function version() public view virtual override returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the RLC encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * accross multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual override returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /**\n     * @dev See {IGovernor-state}.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        ProposalCore memory proposal = _proposals[proposalId];\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (proposal.voteStart.getDeadline() >= block.number) {\n            return ProposalState.Pending;\n        } else if (proposal.voteEnd.getDeadline() >= block.number) {\n            return ProposalState.Active;\n        } else if (proposal.voteEnd.isExpired()) {\n            return\n                _quorumReached(proposalId) && _voteSucceeded(proposalId)\n                    ? ProposalState.Succeeded\n                    : ProposalState.Defeated;\n        } else {\n            revert(\"Governor: unknown proposal id\");\n        }\n    }\n\n    /**\n     * @dev See {IGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteStart.getDeadline();\n    }\n\n    /**\n     * @dev See {IGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteEnd.getDeadline();\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Register a vote with a given support and voting weight.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight\n    ) internal virtual;\n\n    /**\n     * @dev See {IGovernor-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        require(\n            getVotes(msg.sender, block.number - 1) >= proposalThreshold(),\n            \"GovernorCompatibilityBravo: proposer votes below proposal threshold\"\n        );\n\n        uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n\n        require(targets.length == values.length, \"Governor: invalid proposal length\");\n        require(targets.length == calldatas.length, \"Governor: invalid proposal length\");\n        require(targets.length > 0, \"Governor: empty proposal\");\n\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");\n\n        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();\n        uint64 deadline = snapshot + votingPeriod().toUint64();\n\n        proposal.voteStart.setDeadline(snapshot);\n        proposal.voteEnd.setDeadline(deadline);\n\n        emit ProposalCreated(\n            proposalId,\n            _msgSender(),\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            deadline,\n            description\n        );\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-execute}.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        ProposalState status = state(proposalId);\n        require(\n            status == ProposalState.Succeeded || status == ProposalState.Queued,\n            \"Governor: proposal not successful\"\n        );\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overriden to implement different execution mechanism\n     */\n    function _execute(\n        uint256, /* proposalId */\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        string memory errorMessage = \"Governor: call reverted without message\";\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            AddressUpgradeable.verifyCallResult(success, returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Internal cancel mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as\n     * canceled to allow distinguishing it from executed proposals.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n        ProposalState status = state(proposalId);\n\n        require(\n            status != ProposalState.Canceled && status != ProposalState.Expired && status != ProposalState.Executed,\n            \"Governor: proposal not active\"\n        );\n        _proposals[proposalId].canceled = true;\n\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-castVote}.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReason}.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteBySig}.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\n            v,\n            r,\n            s\n        );\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");\n\n        uint256 weight = getVotes(account, proposal.voteStart.getDeadline());\n        _countVote(proposalId, account, support, weight);\n\n        emit VoteCast(account, proposalId, support, weight, reason);\n\n        return weight;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/TimersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Timers.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Tooling for timepoints, timers and delays\n */\nlibrary TimersUpgradeable {\n    struct Timestamp {\n        uint64 _deadline;\n    }\n\n    function getDeadline(Timestamp memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(Timestamp storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(Timestamp storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(Timestamp memory timer) internal view returns (bool) {\n        return timer._deadline > block.timestamp;\n    }\n\n    function isExpired(Timestamp memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.timestamp;\n    }\n\n    struct BlockNumber {\n        uint64 _deadline;\n    }\n\n    function getDeadline(BlockNumber memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(BlockNumber storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(BlockNumber storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(BlockNumber memory timer) internal view returns (bool) {\n        return timer._deadline > block.number;\n    }\n\n    function isExpired(BlockNumber memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.number;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20PermitUpgradeable.sol\";\nimport \"../../../utils/math/MathUpgradeable.sol\";\nimport \"../../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable {\n    function __ERC20Votes_init_unchained() internal onlyInitializing {\n    }\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCastUpgradeable.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal onlyInitializing {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20FlashMintUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20FlashMint.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../../interfaces/IERC3156Upgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC3156 Flash loans extension, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * Adds the {flashLoan} method, which provides flash loan support at the token\n * level. By default there is no fee, but this can be changed by overriding {flashFee}.\n *\n * _Available since v4.1._\n */\nabstract contract ERC20FlashMintUpgradeable is Initializable, ERC20Upgradeable, IERC3156FlashLenderUpgradeable {\n    function __ERC20FlashMint_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC20FlashMint_init_unchained();\n    }\n\n    function __ERC20FlashMint_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /**\n     * @dev Returns the maximum amount of tokens available for loan.\n     * @param token The address of the token that is requested.\n     * @return The amont of token that can be loaned.\n     */\n    function maxFlashLoan(address token) public view override returns (uint256) {\n        return token == address(this) ? type(uint256).max - ERC20Upgradeable.totalSupply() : 0;\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. By default this\n     * implementation has 0 fees. This function can be overloaded to make\n     * the flash loan mechanism deflationary.\n     * @param token The token to be flash loaned.\n     * @param amount The amount of tokens to be loaned.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {\n        require(token == address(this), \"ERC20FlashMint: wrong token\");\n        // silence warning about unused variable without the addition of bytecode.\n        amount;\n        return 0;\n    }\n\n    /**\n     * @dev Performs a flash loan. New tokens are minted and sent to the\n     * `receiver`, who is required to implement the {IERC3156FlashBorrower}\n     * interface. By the end of the flash loan, the receiver is expected to own\n     * amount + fee tokens and have them approved back to the token contract itself so\n     * they can be burned.\n     * @param receiver The receiver of the flash loan. Should implement the\n     * {IERC3156FlashBorrower.onFlashLoan} interface.\n     * @param token The token to be flash loaned. Only `address(this)` is\n     * supported.\n     * @param amount The amount of tokens to be loaned.\n     * @param data An arbitrary datafield that is passed to the receiver.\n     * @return `true` is the flash loan was successful.\n     */\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override returns (bool) {\n        uint256 fee = flashFee(token, amount);\n        _mint(address(receiver), amount);\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,\n            \"ERC20FlashMint: invalid return value\"\n        );\n        uint256 currentAllowance = allowance(address(receiver), address(this));\n        require(currentAllowance >= amount + fee, \"ERC20FlashMint: allowance does not allow refund\");\n        _approve(address(receiver), address(this), currentAllowance - amount - fee);\n        _burn(address(receiver), amount + fee);\n        return true;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC3156Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrowerUpgradeable.sol\";\nimport \"./IERC3156FlashLenderUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashBorrowerUpgradeable {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashLenderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrowerUpgradeable.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashLenderUpgradeable {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "contracts/SteerToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20FlashMintUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\n/// @title Steer Protocol Governance Token\r\n/// @author Steer Protocol\r\n/// @dev This token is used within the governance contracts\r\ncontract SteerToken is\r\n    Initializable,\r\n    ERC20Upgradeable,\r\n    ERC20BurnableUpgradeable,\r\n    PausableUpgradeable,\r\n    OwnableUpgradeable,\r\n    ERC20PermitUpgradeable,\r\n    ERC20VotesUpgradeable,\r\n    ERC20FlashMintUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    function initialize(uint256 initialSupply) public initializer {\r\n        __ERC20_init(\"Steer Protocol\", \"STEER\");\r\n        __ERC20Burnable_init();\r\n        __Pausable_init();\r\n        __Ownable_init();\r\n        __ERC20Permit_init(\"Steer Protocol\");\r\n        __ERC20FlashMint_init();\r\n        __UUPSUpgradeable_init();\r\n\r\n        // Mint intial supply to deployer\r\n        _mint(msg.sender, initialSupply * 10**decimals());\r\n    }\r\n\r\n    /// @dev Pause token transfers in the event of emergency\r\n    /// @dev This will only be used for emergency situations and should not be used for any other reason\r\n    function pause() public onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    /// @dev Unpause token transfers in the event of emergency\r\n    /// @dev This will restore token transfers after an emergency event\r\n    function unpause() public onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    /// @dev Mints tokens to a given address\r\n    /// @param _to The address to transfer to\r\n    /// @param _amount The amount to transfer\r\n    function mint(address _to, uint256 _amount) public onlyOwner {\r\n        _mint(_to, _amount);\r\n    }\r\n\r\n    /// @dev Upgrade proxy support function\r\n    /// @param newImplementation The implementation to upgrade to\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        override\r\n        onlyOwner\r\n    {}\r\n\r\n    /// @dev Before transfer hooks\r\n    /// @dev This function is called before a transfer is made\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override whenNotPaused {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /// @dev After transfer hooks\r\n    /// @dev This function is called before a transfer is made\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\r\n        super._afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function _mint(address to, uint256 amount)\r\n        internal\r\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\r\n    {\r\n        super._mint(to, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount)\r\n        internal\r\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\r\n    {\r\n        super._burn(account, amount);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC20Burnable_init_unchained();\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/tests/UpgradedSteerToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"../SteerToken.sol\";\r\n\r\n/// @title Steer Protocol Governance Token\r\n/// @author Steer Protocol\r\n/// @dev This token is used within the governance contracts\r\ncontract UpgradedSteerToken is SteerToken {\r\n    uint256 public num;\r\n\r\n    function setNum(uint256 _num) external {\r\n        num = _num;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControlUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`.\n     */\n    function __TimelockController_init(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __TimelockController_init_unchained(minDelay, proposers, executors);\n    }\n\n    function __TimelockController_init_unchained(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) internal onlyInitializing {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(id, predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _call(id, i, targets[i], values[i], datas[i]);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     *\n     * Emits a {CallExecuted} event.\n     */\n    function _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) private {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/GovernorTimelockControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IGovernorTimelockUpgradeable.sol\";\nimport \"../GovernorUpgradeable.sol\";\nimport \"../TimelockControllerUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a\n * delay, enforced by the {TimelockController} to all successful proposal (in addition to the voting duration). The\n * {Governor} needs the proposer (an ideally the executor) roles for the {Governor} to work properly.\n *\n * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be\n * inaccessible.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorTimelockControlUpgradeable is Initializable, IGovernorTimelockUpgradeable, GovernorUpgradeable {\n    TimelockControllerUpgradeable private _timelock;\n    mapping(uint256 => bytes32) private _timelockIds;\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /**\n     * @dev Set the timelock.\n     */\n    function __GovernorTimelockControl_init(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __IGovernor_init_unchained();\n        __IGovernorTimelock_init_unchained();\n        __GovernorTimelockControl_init_unchained(timelockAddress);\n    }\n\n    function __GovernorTimelockControl_init_unchained(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        _updateTimelock(timelockAddress);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, GovernorUpgradeable) returns (bool) {\n        return interfaceId == type(IGovernorTimelockUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Overriden version of the {Governor-state} function with added support for the `Queued` status.\n     */\n    function state(uint256 proposalId) public view virtual override(IGovernorUpgradeable, GovernorUpgradeable) returns (ProposalState) {\n        ProposalState status = super.state(proposalId);\n\n        if (status != ProposalState.Succeeded) {\n            return status;\n        }\n\n        // core tracks execution, so we just have to check if successful proposal have been queued.\n        bytes32 queueid = _timelockIds[proposalId];\n        if (queueid == bytes32(0)) {\n            return status;\n        } else if (_timelock.isOperationDone(queueid)) {\n            return ProposalState.Executed;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @dev Public accessor to check the address of the timelock\n     */\n    function timelock() public view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public accessor to check the eta of a queued proposal\n     */\n    function proposalEta(uint256 proposalId) public view virtual override returns (uint256) {\n        uint256 eta = _timelock.getTimestamp(_timelockIds[proposalId]);\n        return eta == 1 ? 0 : eta; // _DONE_TIMESTAMP (1) should be replaced with a 0 value\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");\n\n        uint256 delay = _timelock.getMinDelay();\n        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);\n        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);\n\n        emit ProposalQueued(proposalId, block.timestamp + delay);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Overriden execute function that run the already queued proposal through the timelock.\n     */\n    function _execute(\n        uint256, /* proposalId */\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override {\n        _timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, descriptionHash);\n    }\n\n    /**\n     * @dev Overriden version of the {Governor-_cancel} function to cancel the timelocked proposal if it as already\n     * been queued.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        if (_timelockIds[proposalId] != 0) {\n            _timelock.cancel(_timelockIds[proposalId]);\n            delete _timelockIds[proposalId];\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates\n     * must be proposed, scheduled and executed using the {Governor} workflow.\n     */\n    function updateTimelock(TimelockControllerUpgradeable newTimelock) external virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(TimelockControllerUpgradeable newTimelock) private {\n        emit TimelockChange(address(_timelock), address(newTimelock));\n        _timelock = newTimelock;\n    }\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/GovernorVotes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"../../utils/math/MathUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorVotesUpgradeable is Initializable, GovernorUpgradeable {\n    ERC20VotesUpgradeable public token;\n\n    function __GovernorVotes_init(ERC20VotesUpgradeable tokenAddress) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __IGovernor_init_unchained();\n        __GovernorVotes_init_unchained(tokenAddress);\n    }\n\n    function __GovernorVotes_init_unchained(ERC20VotesUpgradeable tokenAddress) internal onlyInitializing {\n        token = tokenAddress;\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {IGovernor-getVotes}).\n     */\n    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        return token.getPastVotes(account, blockNumber);\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/GovernorVotesQuorumFraction.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./GovernorVotesUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a\n * fraction of the total supply.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorVotesQuorumFractionUpgradeable is Initializable, GovernorVotesUpgradeable {\n    uint256 private _quorumNumerator;\n\n    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);\n\n    function __GovernorVotesQuorumFraction_init(uint256 quorumNumeratorValue) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __IGovernor_init_unchained();\n        __GovernorVotesQuorumFraction_init_unchained(quorumNumeratorValue);\n    }\n\n    function __GovernorVotesQuorumFraction_init_unchained(uint256 quorumNumeratorValue) internal onlyInitializing {\n        _updateQuorumNumerator(quorumNumeratorValue);\n    }\n\n    function quorumNumerator() public view virtual returns (uint256) {\n        return _quorumNumerator;\n    }\n\n    function quorumDenominator() public view virtual returns (uint256) {\n        return 100;\n    }\n\n    function quorum(uint256 blockNumber) public view virtual override returns (uint256) {\n        return (token.getPastTotalSupply(blockNumber) * quorumNumerator()) / quorumDenominator();\n    }\n\n    function updateQuorumNumerator(uint256 newQuorumNumerator) external virtual onlyGovernance {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {\n        require(\n            newQuorumNumerator <= quorumDenominator(),\n            \"GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator\"\n        );\n\n        uint256 oldQuorumNumerator = _quorumNumerator;\n        _quorumNumerator = newQuorumNumerator;\n\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/SteerGovernance.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"./interfaces/ISteerGovernance.sol\";\r\n\r\ncontract SteerGovernance is\r\n    ISteerGovernance,\r\n    Initializable,\r\n    GovernorUpgradeable,\r\n    GovernorSettingsUpgradeable,\r\n    GovernorCompatibilityBravoUpgradeable,\r\n    GovernorVotesUpgradeable,\r\n    GovernorVotesQuorumFractionUpgradeable,\r\n    GovernorTimelockControlUpgradeable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    address internal InternalGovernanceTimeLock;\r\n\r\n    constructor() initializer {}\r\n\r\n    function initialize(\r\n        ERC20VotesUpgradeable _token,\r\n        TimelockControllerUpgradeable _timelock\r\n    ) public initializer {\r\n        __Governor_init(\"SteerGovernance\");\r\n        __GovernorSettings_init(\r\n            1, /* 1 block of voting delay*/\r\n            45818, /* Number of blocks inside voting period */\r\n            100e18 /* Voters need 100 tokens to vote */\r\n        );\r\n        __GovernorCompatibilityBravo_init();\r\n        __GovernorVotes_init(_token);\r\n        __GovernorVotesQuorumFraction_init(\r\n            40 /* 40% */\r\n        );\r\n        __GovernorTimelockControl_init(_timelock);\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        override\r\n        onlyOwner\r\n    {}\r\n\r\n    function votingDelay()\r\n        public\r\n        view\r\n        override(IGovernorUpgradeable, GovernorSettingsUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        return super.votingDelay();\r\n    }\r\n\r\n    function votingPeriod()\r\n        public\r\n        view\r\n        override(IGovernorUpgradeable, GovernorSettingsUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        return super.votingPeriod();\r\n    }\r\n\r\n    function quorum(uint256 blockNumber)\r\n        public\r\n        view\r\n        override(IGovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        return super.quorum(blockNumber);\r\n    }\r\n\r\n    function getVotes(address account, uint256 blockNumber)\r\n        public\r\n        view\r\n        override(IGovernorUpgradeable, GovernorVotesUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        return super.getVotes(account, blockNumber);\r\n    }\r\n\r\n    function state(uint256 proposalId)\r\n        public\r\n        view\r\n        override(\r\n            GovernorUpgradeable,\r\n            IGovernorUpgradeable,\r\n            GovernorTimelockControlUpgradeable\r\n        )\r\n        returns (ProposalState)\r\n    {\r\n        return super.state(proposalId);\r\n    }\r\n\r\n    function propose(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        string memory description\r\n    )\r\n        public\r\n        override(\r\n            GovernorUpgradeable,\r\n            GovernorCompatibilityBravoUpgradeable,\r\n            IGovernorUpgradeable\r\n        )\r\n        returns (uint256)\r\n    {\r\n        return super.propose(targets, values, calldatas, description);\r\n    }\r\n\r\n    function proposalThreshold()\r\n        public\r\n        view\r\n        override(GovernorUpgradeable, GovernorSettingsUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        return super.proposalThreshold();\r\n    }\r\n\r\n    function _execute(\r\n        uint256 proposalId,\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        bytes32 descriptionHash\r\n    )\r\n        internal\r\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\r\n    {\r\n        super._execute(\r\n            proposalId,\r\n            targets,\r\n            values,\r\n            calldatas,\r\n            descriptionHash\r\n        );\r\n    }\r\n\r\n    function _cancel(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        bytes32 descriptionHash\r\n    )\r\n        internal\r\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        // if (msg.sender == InternalGovernanceTimeLock)\r\n        //     return _cancel(targets, values, calldatas, descriptionHash);\r\n        // else\r\n        return super._cancel(targets, values, calldatas, descriptionHash);\r\n    }\r\n\r\n    /// @dev Use this function to set address of Internal Governance Timelock.\r\n    /// @dev This function can only be called once while deployment.\r\n    /// @param _internalGovernanceTimeLock is the address of Internal Governance Timelock.\r\n    function setInternalGovernanceTimeLockOnce(\r\n        address _internalGovernanceTimeLock\r\n    ) external {\r\n        require(\r\n            InternalGovernanceTimeLock == address(0),\r\n            \"Timelock is already set\"\r\n        );\r\n        InternalGovernanceTimeLock = _internalGovernanceTimeLock;\r\n    }\r\n\r\n    /// @dev This function can cancel a proposal irrespective of votes on it.\r\n    /// @dev This function can only be called by Internal Governance Timelock.\r\n    ///So only after there are enough votes in Internal Governance this function can be called.\r\n    function cancelByInternalGovernance(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        bytes32 descriptionHash\r\n    ) public {\r\n        require(\r\n            msg.sender == InternalGovernanceTimeLock,\r\n            \"Not Internal Governance\"\r\n        );\r\n        _cancel(targets, values, calldatas, descriptionHash);\r\n        emit CancelledByInternalGovernance(\r\n            targets,\r\n            values,\r\n            calldatas,\r\n            descriptionHash\r\n        );\r\n    }\r\n\r\n    function _executor()\r\n        internal\r\n        view\r\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\r\n        returns (address)\r\n    {\r\n        return super._executor();\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override(\r\n            GovernorUpgradeable,\r\n            IERC165Upgradeable,\r\n            GovernorTimelockControlUpgradeable\r\n        )\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ISteerGovernance.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\ninterface ISteerGovernance {\r\n    event CancelledByInternalGovernance(\r\n        address[] targets,\r\n        uint256[] values,\r\n        bytes[] calldatas,\r\n        bytes32 descriptionHash\r\n    );\r\n\r\n    function setInternalGovernanceTimeLockOnce(\r\n        address _internalGovernanceTimeLock\r\n    ) external;\r\n\r\n    function cancelByInternalGovernance(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        bytes32 descriptionHash\r\n    ) external;\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/GovernorSettings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for settings updatable through governance.\n *\n * _Available since v4.4._\n */\nabstract contract GovernorSettingsUpgradeable is Initializable, GovernorUpgradeable {\n    uint256 private _votingDelay;\n    uint256 private _votingPeriod;\n    uint256 private _proposalThreshold;\n\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /**\n     * @dev Initialize the governance parameters.\n     */\n    function __GovernorSettings_init(\n        uint256 initialVotingDelay,\n        uint256 initialVotingPeriod,\n        uint256 initialProposalThreshold\n    ) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __IGovernor_init_unchained();\n        __GovernorSettings_init_unchained(initialVotingDelay, initialVotingPeriod, initialProposalThreshold);\n    }\n\n    function __GovernorSettings_init_unchained(\n        uint256 initialVotingDelay,\n        uint256 initialVotingPeriod,\n        uint256 initialProposalThreshold\n    ) internal onlyInitializing {\n        _setVotingDelay(initialVotingDelay);\n        _setVotingPeriod(initialVotingPeriod);\n        _setProposalThreshold(initialProposalThreshold);\n    }\n\n    /**\n     * @dev See {IGovernor-votingDelay}.\n     */\n    function votingDelay() public view virtual override returns (uint256) {\n        return _votingDelay;\n    }\n\n    /**\n     * @dev See {IGovernor-votingPeriod}.\n     */\n    function votingPeriod() public view virtual override returns (uint256) {\n        return _votingPeriod;\n    }\n\n    /**\n     * @dev See {Governor-proposalThreshold}.\n     */\n    function proposalThreshold() public view virtual override returns (uint256) {\n        return _proposalThreshold;\n    }\n\n    /**\n     * @dev Update the voting delay. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function setVotingDelay(uint256 newVotingDelay) public virtual onlyGovernance {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    /**\n     * @dev Update the voting period. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function setVotingPeriod(uint256 newVotingPeriod) public virtual onlyGovernance {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    /**\n     * @dev Update the proposal threshold. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    /**\n     * @dev Internal setter for the voting delay.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function _setVotingDelay(uint256 newVotingDelay) internal virtual {\n        emit VotingDelaySet(_votingDelay, newVotingDelay);\n        _votingDelay = newVotingDelay;\n    }\n\n    /**\n     * @dev Internal setter for the voting period.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) internal virtual {\n        // voting period must be at least one block long\n        require(newVotingPeriod > 0, \"GovernorSettings: voting period too low\");\n        emit VotingPeriodSet(_votingPeriod, newVotingPeriod);\n        _votingPeriod = newVotingPeriod;\n    }\n\n    /**\n     * @dev Internal setter for the proposal threshold.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {\n        emit ProposalThresholdSet(_proposalThreshold, newProposalThreshold);\n        _proposalThreshold = newProposalThreshold;\n    }\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/StakingRewards.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\n// Inheritance\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\r\nimport \"./interfaces/IStakingRewards.sol\";\r\n\r\n/// @title Staking reward contract\r\n/// @author Steer Protocol\r\n/// @dev This contract is used to reward stakers for their staking time.\r\ncontract StakingRewards is\r\n    IStakingRewards,\r\n    Initializable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n    // Storage\r\n\r\n    // Constants\r\n    uint256 constant PRECISION = 1e18;\r\n    uint256 constant SECONDS_IN_YEAR = 31536000;\r\n    uint256 constant RATE_PRECISION = 10000; //Precision for reward calculaion\r\n\r\n    // Mapping of Pool details to pool id\r\n    mapping(uint256 => Pool) public pools;\r\n\r\n    // Total no. of pools created\r\n    uint256 public totalPools;\r\n\r\n    // Mapping of deposit addresses and the block time they were last rewarded\r\n    mapping(address => mapping(uint256 => uint256)) public lastRewarded;\r\n\r\n    // Mapping of deposit addresses and the amount of rewards claimed but not withdrawn\r\n    mapping(address => mapping(uint256 => uint256)) public rewards;\r\n\r\n    // Total amount of staked tokens mapped to each deposit address\r\n    mapping(address => mapping(uint256 => uint256)) public balances;\r\n\r\n    // Mapping of total rewards allocated currently for a pool\r\n    mapping(uint256 => uint256) public totalRewardsPerPool;\r\n\r\n    // Mapping that returns the state of pool by passing pool id, true means staking is paused and false means staking is allowed\r\n    mapping(uint256 => bool) public isPaused;\r\n\r\n    // Mapping that returns pending rewards for a particular user for a particular pool\r\n    mapping(address => mapping(uint256 => uint256)) public pendingRewards;\r\n\r\n    // External Functions\r\n\r\n    /// @dev To create a staking pool\r\n    /// @param stakingToken Address of the token that will be staked\r\n    /// @param rewardToken Address of the token that will be given as reward\r\n    /// @param rewardRate Rate at which the rewards will be calculated yearly and then multiplied by 100\r\n    /// @param start Start time of the staking pool\r\n    /// @param end Ending time for the staking pool\r\n    function createPool(\r\n        address stakingToken,\r\n        address rewardToken,\r\n        uint256 rewardRate,\r\n        uint256 start,\r\n        uint256 end\r\n    ) external onlyOwner {\r\n        uint256 _totalPools = totalPools;\r\n        pools[_totalPools] = Pool({\r\n            stakingToken: stakingToken,\r\n            rewardToken: rewardToken,\r\n            rewardRate: rewardRate * 100,\r\n            totalAmount: 0,\r\n            start: start,\r\n            end: end\r\n        });\r\n        ++totalPools;\r\n    }\r\n\r\n    /// @dev To stake tokens\r\n    /// @param amount The number of tokens to be staked.\r\n    /// @param poolId The id of the pool in which tokens should be staked.\r\n    function stake(uint256 amount, uint256 poolId) external {\r\n        _stake(msg.sender, amount, poolId);\r\n    }\r\n\r\n    /// @dev To stake tokens\r\n    /// @param user The address that stake tokens for.\r\n    /// @param amount The number of tokens to be staked.\r\n    /// @param poolId The id of the pool in which tokens should be staked.\r\n    function stakeFor(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 poolId\r\n    ) external {\r\n        _stake(user, amount, poolId);\r\n    }\r\n\r\n    /// @dev To unstake staked tokens.\r\n    /// @param poolId The id of pool from which the tokens whould be unstaked.\r\n    function unstake(uint256 poolId) external {\r\n        Pool memory pool = pools[poolId];\r\n        uint256 amount = balances[msg.sender][poolId];\r\n        pools[poolId].totalAmount -= amount;\r\n        if (block.timestamp > pool.end) {\r\n            claimReward(poolId, pool);\r\n        } else {\r\n            lastRewarded[msg.sender][poolId] = 0;\r\n            rewards[msg.sender][poolId] = 0;\r\n            balances[msg.sender][poolId] = 0;\r\n        }\r\n        IERC20Upgradeable(pool.stakingToken).safeTransfer(msg.sender, amount);\r\n        emit Withdrawn(msg.sender, amount, poolId);\r\n    }\r\n\r\n    /// @dev To deposit reward tokens that will be given to the stakers.\r\n    /// @param poolId The id of the pool in which rewards should be allocated\r\n    /// @param amount The value of tokens that should be added to give out as rewards.\r\n    function depositRewards(uint256 poolId, uint256 amount) external {\r\n        totalRewardsPerPool[poolId] += amount;\r\n        emit RewardsDeposited(msg.sender, poolId, amount);\r\n        IERC20Upgradeable(pools[poolId].rewardToken).safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            amount\r\n        );\r\n    }\r\n\r\n    /// @dev To withdraw the extra rewards that remains on the contract\r\n    ///      and can only be called by owner of this contract.\r\n    /// @param poolId The id of the pool in which rewards should be withdrawn\r\n    /// @param amount The value of tokens that should be removed from the contract.\r\n    /// @param receiver The address where the withdrawn tokens should be sent\r\n    function withdrawRewards(\r\n        uint256 poolId,\r\n        uint256 amount,\r\n        address receiver\r\n    ) external onlyOwner {\r\n        // Reduce totalRewards by amount.\r\n        // Owner cannot withdraw more rewards than they have deposited.\r\n        totalRewardsPerPool[poolId] -= amount;\r\n        emit RewardsWithdrawn(amount, poolId);\r\n        IERC20Upgradeable(pools[poolId].rewardToken).safeTransfer(\r\n            receiver,\r\n            amount\r\n        );\r\n    }\r\n\r\n    /// @dev To pause or resume a particular staking pool\r\n    /// @param poolId The id of the staking pool that should be paused or resumed\r\n    /// @param pause The boolean where passing true means pause the pool\r\n    ///              and passing false means resume the pool\r\n    function toggleStakingInPool(uint256 poolId, bool pause)\r\n        external\r\n        onlyOwner\r\n    {\r\n        isPaused[poolId] = pause;\r\n    }\r\n\r\n    /// @dev To claim the pending rewards\r\n    /// @param poolId The id of the pool from which the pending rewards should be claimed\r\n    function claimPendingRewards(uint256 poolId) external {\r\n        uint256 pending = pendingRewards[msg.sender][poolId];\r\n        pendingRewards[msg.sender][poolId] = 0;\r\n        totalRewardsPerPool[poolId] -= pending;\r\n        IERC20Upgradeable(pools[poolId].rewardToken).safeTransfer(\r\n            msg.sender,\r\n            pending\r\n        );\r\n    }\r\n\r\n    /// @dev To get rewards for a particular address for a particular pool\r\n    /// @param account The address of the account whose reward is to be fetched\r\n    /// @param poolId The id of the pool from which rewards for the account needs to be fetched\r\n    function getRewardsForAPool(address account, uint256 poolId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Pool memory pool = pools[poolId];\r\n        uint256 stakeTime;\r\n        if (block.timestamp > pool.end) stakeTime = pool.end;\r\n        else stakeTime = block.timestamp;\r\n        uint256 currentReward = (balances[account][poolId] *\r\n            (((stakeTime - lastRewarded[account][poolId]) *\r\n                (pool.rewardRate * PRECISION)) /\r\n                (RATE_PRECISION * SECONDS_IN_YEAR))) / PRECISION;\r\n        currentReward += rewards[account][poolId];\r\n        return currentReward;\r\n    }\r\n\r\n    // Public Functions\r\n\r\n    function initialize() public initializer {\r\n        __UUPSUpgradeable_init();\r\n        __Ownable_init();\r\n    }\r\n\r\n    /// @dev To get the pool for given id\r\n    /// @return Pool which has the details for every pool\r\n    function getPool(uint256 poolId) public view returns (Pool memory) {\r\n        return pools[poolId];\r\n    }\r\n\r\n    /// @dev To get the details for all pools\r\n    /// @return pools which has the details for every pool\r\n    function getPools() public view returns (Pool[] memory, string[] memory) {\r\n        uint256 _totalPools = totalPools;\r\n        Pool[] memory _pools = new Pool[](_totalPools);\r\n        string[] memory symbols = new string[](_totalPools);\r\n        for (uint256 i; i != _totalPools; ++i) {\r\n            _pools[i] = pools[i];\r\n            string memory stakingTokenSymbol = IERC20Metadata(\r\n                _pools[i].stakingToken\r\n            ).symbol();\r\n            string memory rewardTokenSymbol = IERC20Metadata(\r\n                _pools[i].rewardToken\r\n            ).symbol();\r\n            symbols[i] = string(\r\n                abi.encodePacked(stakingTokenSymbol, \"/\", rewardTokenSymbol)\r\n            );\r\n        }\r\n        return (_pools, symbols);\r\n    }\r\n\r\n    function getBalances(address user)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256 _totalPools = totalPools;\r\n        uint256[] memory _balances = new uint256[](_totalPools);\r\n        for (uint256 i; i != _totalPools; ++i)\r\n            _balances[i] = balances[user][i];\r\n        return _balances;\r\n    }\r\n\r\n    // Internal Functions\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        override\r\n        onlyOwner\r\n    {}\r\n\r\n    function claimReward(uint256 poolId, Pool memory pool) internal {\r\n        updateReward(poolId, pool);\r\n        uint256 reward = rewards[msg.sender][poolId];\r\n        rewards[msg.sender][poolId] = 0;\r\n        balances[msg.sender][poolId] = 0;\r\n        lastRewarded[msg.sender][poolId] = 0;\r\n        uint256 totalRewards = totalRewardsPerPool[poolId];\r\n        if (totalRewards >= reward) {\r\n            totalRewardsPerPool[poolId] = totalRewards - reward;\r\n            emit RewardPaid(msg.sender, poolId, reward);\r\n            IERC20Upgradeable(pool.stakingToken).safeTransfer(\r\n                msg.sender,\r\n                reward\r\n            );\r\n        } else {\r\n            pendingRewards[msg.sender][poolId] = reward - totalRewards;\r\n            totalRewardsPerPool[poolId] = 0;\r\n            emit RewardPaid(msg.sender, poolId, totalRewards);\r\n            IERC20Upgradeable(pool.stakingToken).safeTransfer(\r\n                msg.sender,\r\n                totalRewards\r\n            );\r\n        }\r\n    }\r\n\r\n    function updateReward(uint256 poolId, Pool memory pool) internal {\r\n        uint256 stakeTime;\r\n        if (block.timestamp > pool.end) stakeTime = pool.end;\r\n        else stakeTime = block.timestamp;\r\n        uint256 lastReward = (balances[msg.sender][poolId] *\r\n            (((stakeTime - lastRewarded[msg.sender][poolId]) *\r\n                (pool.rewardRate * PRECISION)) /\r\n                (RATE_PRECISION * SECONDS_IN_YEAR))) / PRECISION;\r\n        lastRewarded[msg.sender][poolId] = stakeTime;\r\n        rewards[msg.sender][poolId] += lastReward;\r\n    }\r\n\r\n    /// @dev To stake tokens\r\n    /// @param user The address that stake tokens for.\r\n    /// @param amount The number of tokens to be staked.\r\n    /// @param poolId The id of the pool in which tokens should be staked.\r\n    function _stake(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 poolId\r\n    ) internal {\r\n        // Validate\r\n        require(amount > 0, \"Cannot stake 0\");\r\n        Pool memory pool = pools[poolId];\r\n        require(pool.start <= block.timestamp, \"Staking not started\");\r\n        require(isPaused[poolId] == false, \"Staking Paused\");\r\n        require(block.timestamp < pool.end, \"Staking Period is over\");\r\n\r\n        // Update values before staking\r\n        updateReward(poolId, pool);\r\n\r\n        // Stake\r\n        balances[user][poolId] += amount;\r\n        pools[poolId].totalAmount += amount;\r\n        IERC20Upgradeable(pool.stakingToken).safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            amount\r\n        );\r\n        emit Staked(user, amount, poolId);\r\n    }\r\n}\r\n"
    },
    "contracts/UintOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\n/// @title Structure for Uint Oracle vaults\r\n/// @author Steer Protocol\r\n/// @dev All uint oracle vaults will follow this structure\r\ncontract UintOracle is Initializable, OwnableUpgradeable, UUPSUpgradeable {\r\n    //Address of the orchestrator, this is the only contract having access to update data in this oracle\r\n    address public orchestrator;\r\n    //Address of the creator of this vault\r\n    address public creator;\r\n    //Most recent data of this oracle\r\n    uint256 public data;\r\n    //Name of this oracle\r\n    string public oracleName;\r\n\r\n    /// @dev Oracle Updation event\r\n    /// @param data is the updated data\r\n    event OracleUpdated(uint256 data);\r\n\r\n    constructor() {}\r\n\r\n    function initialize(\r\n        address _orchestrator,\r\n        address,\r\n        address,\r\n        bytes calldata _params\r\n    ) external initializer {\r\n        (creator, oracleName) = abi.decode(_params, (address, string));\r\n        __UUPSUpgradeable_init();\r\n        __Ownable_init();\r\n        orchestrator = _orchestrator;\r\n    }\r\n\r\n    /// @dev Updates the data on this oracle\r\n    /// @dev Only orchestrator can call this function\r\n    /// @param _data is the most updated value that should be stored on this oracle\r\n    function updateOracle(uint256 _data) external {\r\n        require(msg.sender == orchestrator, \"Unauthorized\");\r\n        data = _data;\r\n        emit OracleUpdated(_data);\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        virtual\r\n        override\r\n    {}\r\n}\r\n"
    },
    "contracts/tests/TestToken2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\ncontract TestToken2 is\r\n    Initializable,\r\n    ERC20Upgradeable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() initializer {}\r\n\r\n    function initialize(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint256 _amount\r\n    ) public initializer {\r\n        __ERC20_init(_name, _symbol);\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n        _mint(msg.sender, _amount * 10**18);\r\n    }\r\n\r\n    function mint(address to, uint256 amount) public onlyOwner {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        override\r\n        onlyOwner\r\n    {}\r\n}\r\n"
    },
    "contracts/tests/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\ncontract TestToken is\r\n    Initializable,\r\n    ERC20Upgradeable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() initializer {}\r\n\r\n    function initialize(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint256 _amount\r\n    ) public initializer {\r\n        __ERC20_init(_name, _symbol);\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n        _mint(msg.sender, _amount * 10**18);\r\n    }\r\n\r\n    function mint(address to, uint256 amount) public onlyOwner {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        override\r\n        onlyOwner\r\n    {}\r\n}\r\n"
    },
    "contracts/tests/dummyContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"../interfaces/IGasVault.sol\";\r\nimport \"../interfaces/IImplementation.sol\";\r\n\r\n// Created just to have something to run orchestrator actions on so testing is easy\r\ncontract DummyContract is\r\n    Initializable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable,\r\n    IImplementation\r\n{\r\n    uint256 public num;\r\n    uint256[] public gasInTransaction;\r\n    IGasVault public gasVault;\r\n\r\n    function changeNum(uint256 newNum) public {\r\n        assert(newNum != 196);\r\n        num = newNum;\r\n    }\r\n\r\n    function initialize(\r\n        address,\r\n        address _steer,\r\n        address,\r\n        bytes calldata\r\n    ) public initializer {\r\n        __UUPSUpgradeable_init();\r\n        __Ownable_init();\r\n        _transferOwnership(_steer);\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        override\r\n        onlyOwner\r\n    {}\r\n\r\n    function recordGas() public {\r\n        gasInTransaction.push(gasleft());\r\n    }\r\n\r\n    function setNumTo50() public {\r\n        num = 50;\r\n    }\r\n\r\n    function setNumToMultiple(uint256 firstNum, uint256 secondNum) external {\r\n        num = firstNum * secondNum;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IGasVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\ninterface IGasVault {\r\n    event Deposited(\r\n        address indexed origin,\r\n        address indexed target,\r\n        uint256 amount\r\n    );\r\n    event Withdrawn(\r\n        address indexed targetAddress,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n    event EtherUsed(address indexed account, uint256 amount, bytes32 jobHash);\r\n\r\n    function deposit(address targetAddress) external payable;\r\n\r\n    /**\r\n     * @dev Withdraws given amount of ether from the vault.\r\n     * @param amount Amount of ether to withdraw, in terms of wei.\r\n     */\r\n    function withdraw(\r\n        uint256 amount,\r\n        address targetAddress,\r\n        address to\r\n    ) external;\r\n\r\n    function withdraw(uint256 amount, address to) external;\r\n\r\n    /**\r\n     * @dev calculates total transactions remaining. What this means is--assuming that each method (action paid for by the strategist/job owner)\r\n     *      costs max amount of gas at max gas price, and uses the max amount of actions, how many transactions can be paid for?\r\n     *      In other words, how many actions can this vault guarantee.\r\n     * @param targetAddress is address actions will be performed on, and address paying gas for those actions.\r\n     * @param highGasEstimate is highest reasonable gas price assumed for the actions\r\n     * @return total transactions remaining, assuming max gas is used in each Method\r\n     */\r\n    function transactionsRemaining(\r\n        address targetAddress,\r\n        uint256 highGasEstimate\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @param targetAddress is address actions will be performed on, and address paying gas for those actions.\r\n     * @return uint256 gasAvailable (representing amount of gas available per Method).\r\n     */\r\n    function gasAvailableForTransaction(address targetAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @param targetAddress is address actions were performed on\r\n     * @param originalGas is gas passed in to the action execution order. Used to calculate gas used in the execution.\r\n     * @dev should only ever be called by the orchestrator. Is onlyOrchestrator. This and setAsideGas are used to pull gas from the vault for strategy executions.\r\n     */\r\n    function reimburseGas(\r\n        address targetAddress,\r\n        uint256 originalGas,\r\n        bytes32 newActionHash\r\n    ) external;\r\n}\r\n"
    },
    "contracts/Orchestrator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport { IGasVault } from \"./interfaces/IGasVault.sol\";\r\nimport { IOrchestrator } from \"./interfaces/IOrchestrator.sol\";\r\nimport { IKeeperRegistry } from \"./interfaces/IKeeperRegistry.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\n/*\r\n    note there is no current on-chain method for slashing misbehaving strategies. The worst misbehaving strategies can do is trigger repeated calls to this contract.\r\n\r\n    note This contract relies on the assumption that jobs can only be created by vault and strategy creators. The most serious incorrect target addresses (the orchestrator\r\n    address and the gasVault address) are blocked, but other vaults are protected by the keepers themselves.\r\n */\r\ncontract Orchestrator is IOrchestrator, OwnableUpgradeable, UUPSUpgradeable {\r\n    uint256 public constant actionThresholdPercent = 51; // If an action is approved by >= approvalThresholdPercent members, it is approved\r\n\r\n    // Address of GasVault, which is the contract used to recompense keepers for gas they spent executing actions\r\n    address public gasVault;\r\n\r\n    // Address of Keeper Registry, which handles keeper verification\r\n    address public keeperRegistry;\r\n\r\n    // Operator node action participation reward. Currently unused.\r\n    uint256 public rewardPerAction;\r\n\r\n    /*\r\n        bytes32 is hash of action. Calculated using keccak256(abi.encode(targetAddress, jobEpoch, calldatas))\r\n\r\n        Action approval meaning:\r\n        0: Pending\r\n        1: Approved\r\n        Both votes and overall approval status follow this standard.\r\n    */\r\n    mapping(bytes32 => ActionState) public actions;\r\n\r\n    /*  \r\n        actionHash => uint256 where each bit represents one keeper vote.\r\n    */\r\n    mapping(bytes32 => uint256) public voteBitmaps;\r\n\r\n    /**\r\n     * @dev initialize the Orchestrator\r\n     * @param _keeperRegistry address of the keeper registry\r\n     * @param _rewardPerAction is # of SteerToken to give to operator nodes for each completed action (currently unused)\r\n     */\r\n    function initialize(address _keeperRegistry, uint256 _rewardPerAction)\r\n        external\r\n        initializer\r\n    {\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n        keeperRegistry = _keeperRegistry;\r\n        rewardPerAction = _rewardPerAction;\r\n    }\r\n\r\n    /**\r\n     * @dev allows owner to set/update gas vault address. Mainly used to resolve mutual dependency.\r\n     */\r\n    function setGasVault(address _gasVault) external onlyOwner {\r\n        gasVault = _gasVault;\r\n    }\r\n\r\n    function _authorizeUpgrade(address) internal override onlyOwner {}\r\n\r\n    /**\r\n     * @dev set the reward given to operator nodes for their participation in a strategy calculation\r\n     * @param _rewardPerAction is amount of steer token to be earned as a reward, per participating operator node per action.\r\n     */\r\n    function setRewardPerAction(uint256 _rewardPerAction) external onlyOwner {\r\n        rewardPerAction = _rewardPerAction;\r\n    }\r\n\r\n    /**\r\n     * @dev vote (if you are a keeper) on a given action proposal\r\n     * @param actionHash is the hash of the action to be voted on\r\n     * @param vote is the vote to be cast. false: reject, true: approve. false only has an effect if the keeper previously voted true. It resets their vote to false.\r\n     */\r\n    function voteOnAction(bytes32 actionHash, bool vote) public {\r\n        // Get voter keeper license, use to construct bitmap. Revert if no license.\r\n        uint256 license = IKeeperRegistry(keeperRegistry).checkLicense(\r\n            msg.sender\r\n        );\r\n        uint256 bitmap = 1 << license;\r\n        if (vote) {\r\n            // Add vote to bitmap through OR\r\n            voteBitmaps[actionHash] |= bitmap;\r\n        } else {\r\n            // Remove vote from bitmap through XOR. Note that this will send a vote FOR the action if the keeper had not previously voted.\r\n            voteBitmaps[actionHash] ^= bitmap;\r\n        }\r\n        emit Vote(actionHash, msg.sender, vote);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if an action with given `actionId` is approved by all existing members of the group.\r\n     * Its up to the contract creators to decide if this method should look at majority votes (based on ownership)\r\n     * or if it should ask consent of all the users irrespective of their ownerships.\r\n     */\r\n    function actionApprovalStatus(bytes32 actionHash)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        /*\r\n            maxLicenseId represents the number at which the below for loop should stop checking the bitmap for votes. It's 1 greater than the last keeper's\r\n            bitmap number so that the loop ends after handling the last keeper.\r\n        */\r\n        uint256 maxLicenseId = IKeeperRegistry(keeperRegistry)\r\n            .maxNumKeepers() + 1;\r\n        uint256 yesVotes;\r\n        uint256 voteDifference;\r\n        uint256 voteBitmap = voteBitmaps[actionHash];\r\n        for (uint256 i = 1; i != maxLicenseId; ++i) {\r\n            // Get bit which this keeper has control over\r\n            voteDifference = 1 << i;\r\n\r\n            // If the bit at this keeper's position has been flipped to 1, they approved this action\r\n            if ((voteBitmap & voteDifference) == voteDifference) {\r\n                ++yesVotes;\r\n            }\r\n        }\r\n\r\n        // Check current keeper count to get threshold\r\n        uint256 numKeepers = IKeeperRegistry(keeperRegistry)\r\n            .currentNumKeepers();\r\n\r\n        // If there happen to be no keepers, div by zero error will happen here, preventing actions from being executed.\r\n        if ((yesVotes * 100) / numKeepers >= actionThresholdPercent) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Executes the action referenced by the given `actionId` as long as it is approved actionThresholdPercent of group.\r\n     * The executeAction executes all methods as part of given action in an atomic way (either all should succeed or none should succeed).\r\n     * Once executed, the action should be set as executed (state=3) so that it cannot be executed again.\r\n\r\n     * @param targetAddress is the address which will be receiving the action's calls.\r\n     * @param jobEpoch is the job epoch of this action.\r\n     * @param calldatas is the COMPLETE calldata of each method to be called\r\n     * note that the hash is created using the sliced calldata, but here it must be complete or the method will revert.\r\n     * @param timeIndependentLengths--For each calldata, the number of bytes that is NOT time-sensitive. If no calldatas are time-sensitive, just pass an empty array.\r\n     * @param jobHash is the identifier for the job this action is related to. This is used for DynamicJobs to identify separate jobs to the subgraph.\r\n     * @return actionState corresponding to post-execution action state. Pending if execution failed, Completed if execution succeeded.\r\n     */\r\n    function executeAction(\r\n        address targetAddress,\r\n        uint256 jobEpoch,\r\n        bytes[] calldata calldatas,\r\n        uint256[] calldata timeIndependentLengths,\r\n        bytes32 jobHash\r\n    ) external returns (ActionState) {\r\n        // Make sure this action is approved and has not yet been executed\r\n        bytes32 actionHash;\r\n        if (timeIndependentLengths.length == 0) {\r\n            // If none of the data is time-sensitive, just use passed in calldatas\r\n            actionHash = keccak256(\r\n                abi.encode(targetAddress, jobEpoch, calldatas)\r\n            );\r\n        } else {\r\n            // If some of it is time-sensitive, create a new array using timeIndependentLengths to represent what was originally passed in, then compare that hash instead\r\n            uint256 calldataCount = timeIndependentLengths.length;\r\n\r\n            // Construct original calldatas\r\n            bytes[] memory timeIndependentCalldatas = new bytes[](\r\n                calldataCount\r\n            );\r\n            for (uint256 i; i != calldataCount; ++i) {\r\n                timeIndependentCalldatas[i] = calldatas[\r\n                    i\r\n                ][:timeIndependentLengths[i]];\r\n            }\r\n\r\n            // Create hash from sliced calldatas\r\n            actionHash = keccak256(\r\n                abi.encode(targetAddress, jobEpoch, timeIndependentCalldatas)\r\n            );\r\n        }\r\n\r\n        // Ensure action has not yet been executed\r\n        require(\r\n            actions[actionHash] == ActionState.PENDING,\r\n            \"Action already executed\"\r\n        );\r\n\r\n        // Make sure this action isn't illegal (must be checked here, since elsewhere the contract only knows the action hash)\r\n        require(targetAddress != address(this), \"Invalid target address\");\r\n        require(targetAddress != gasVault, \"Invalid target address\");\r\n\r\n        // Have this keeper vote for action. This also checks that the caller is a keeper.\r\n        voteOnAction(actionHash, true);\r\n\r\n        // Check action approval status, execute accordingly.\r\n        bool actionApproved = actionApprovalStatus(actionHash);\r\n        if (actionApproved) {\r\n            // Set aside gas for this action. Keeper will be reimbursed ((originalGas - [gas remaining when returnGas is called]) * gasPrice) wei.\r\n            uint256 originalGas = gasleft();\r\n\r\n            // Execute action\r\n            (bool success, ) = address(this).call{ // Check gas available for this transaction. This call will fail if gas available is insufficient or this call's gas price is too high.\r\n                gas: IGasVault(gasVault).gasAvailableForTransaction(\r\n                    targetAddress\r\n                )\r\n            }(\r\n                abi.encodeWithSignature(\r\n                    \"_executeAction(address,bytes[])\",\r\n                    targetAddress,\r\n                    calldatas\r\n                )\r\n            );\r\n\r\n            // Reimburse keeper for gas used, whether action execution succeeded or not. The reimbursement will be stored inside the GasVault.\r\n            IGasVault(gasVault).reimburseGas(\r\n                targetAddress,\r\n                originalGas,\r\n                jobHash == bytes32(0) ? actionHash : jobHash // If a jobhash was passed in, use that. Otherwise use the action hash.\r\n            );\r\n\r\n            // Record result\r\n            if (success) {\r\n                emit ActionExecuted(actionHash, _msgSender(), rewardPerAction);\r\n\r\n                // Set state to completed\r\n                actions[actionHash] = ActionState.COMPLETED;\r\n\r\n                return ActionState.COMPLETED;\r\n            } else {\r\n                emit ActionFailed(actionHash);\r\n\r\n                return ActionState.PENDING;\r\n            }\r\n        } else {\r\n            // If action is not approved, revert.\r\n            revert(\"Votes lacking; state still pending\");\r\n        }\r\n    }\r\n\r\n    function _executeAction(address targetAddress, bytes[] calldata calldatas)\r\n        external\r\n    {\r\n        require(\r\n            msg.sender == address(this),\r\n            \"Only Orchestrator can call this function\"\r\n        );\r\n\r\n        bool success;\r\n        uint256 calldataCount = calldatas.length;\r\n        for (uint256 i; i != calldataCount; ++i) {\r\n            (success, ) = targetAddress.call(calldatas[i]);\r\n\r\n            // If any method fails, the action will revert, reverting all other methods but still pulling gas used from the GasVault.\r\n            require(success);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IKeeperRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\ninterface IKeeperRegistry {\r\n    enum permissionType {\r\n        NONE,\r\n        FULL,\r\n        SLASHED\r\n    }\r\n\r\n    /**\r\n     * Any given address can be in one of three different states:\r\n        1. Not a keeper.\r\n        2. A former keeper who is queued to leave, i.e. they no longer have a keeper license but still have some funds locked in the contract. \r\n        3. A current keeper.\r\n     * Keepers can themselves each be in one of two states:\r\n        1. In good standing. This is signified by bondHeld >= bondAmount.\r\n        2. Not in good standing. \r\n        If a keepers is not in good standing, they retain their license and ability to vote, but any slash will remove their privileges.\r\n     * The only way for a keeper's bondHeld to drop to 0 is for them to leave or be slashed. Either way they lose their license in the process.\r\n     */\r\n    struct WorkerDetails {\r\n        uint256 bondHeld; // bondCoin held by this keeper.\r\n        uint256 licenseNumber; // Index of this keeper in the license mapping, i.e. which license they own. If they don't own a license, this will be 0.\r\n        uint256 leaveTimestamp; // If this keeper has queued to leave, they can withdraw their bond after this date.\r\n    }\r\n\r\n    event PermissionChanged(\r\n        address indexed _subject,\r\n        permissionType indexed _permissionType\r\n    );\r\n    event LeaveQueued(address indexed keeper, uint256 leaveTimestamp);\r\n\r\n    /**\r\n     * @param coinAddress the address of the ERC20 which will be used for bonds; intended to be Steer token.\r\n     * @param keeperTransferDelay the amount of time (in seconds) between when a keeper relinquishes their license and when they can\r\n            withdraw their funds. Intended to be 2 weeks - 1 month.\r\n     */\r\n    function initialize(\r\n        address coinAddress,\r\n        uint256 keeperTransferDelay,\r\n        uint256 maxKeepers,\r\n        uint256 bondSize\r\n    ) external;\r\n\r\n    function maxNumKeepers() external view returns (uint256);\r\n\r\n    function currentNumKeepers() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev setup utility function for owner to add initial keepers. Addresses must each be unique and not hold any bondToken.\r\n     * @param joiners array of addresses to become keepers.\r\n     * note that this function will pull bondToken from the owner equal to bondAmount * numJoiners.\r\n     */\r\n    function joiningForOwner(address[] calldata joiners) external;\r\n\r\n    /**\r\n     * @param amount Amount of bondCoin to be deposited.\r\n     * @dev this function has three uses:\r\n        1. If the caller is a keeper, they can increase their bondHeld by amount.\r\n        2. If the caller is not a keeper or former keeper, they can attempt to claim a keeper license and become a keeper.\r\n        3. If the caller is a former keeper, they can attempt to cancel their leave request, claim a keeper license, and become a keeper.\r\n        In all 3 cases registry[msg.sender].bondHeld is increased by amount. In the latter 2, msg.sender's bondHeld after the transaction must be >= bondAmount.\r\n     */\r\n    function join(uint256 licenseNumber, uint256 amount) external;\r\n\r\n    function queueToLeave() external;\r\n\r\n    function leave() external;\r\n\r\n    /**\r\n     * @dev returns true if the given address has the power to vote, false otherwise. The address has the power to vote if it is within the keeper array.\r\n     */\r\n    function checkLicense(address targetAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev slashes a keeper, removing their permissions and forfeiting their bond.\r\n     * @param targetKeeper keeper to denounce\r\n     * @param amount amount of bondCoin to slash\r\n     */\r\n    function denounce(address targetKeeper, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev withdraws slashed tokens from the vault and sends them to targetAddress.\r\n     * @param amount amount of bondCoin to withdraw\r\n     * @param targetAddress address receiving the tokens\r\n     */\r\n    function withdrawFreeCoin(uint256 amount, address targetAddress) external;\r\n\r\n    /**\r\n     * @dev change bondAmount to a new value.\r\n     * @dev implicitly changes keeper permissions. If the bondAmount is being increased, existing keepers will not be slashed or removed. \r\n            note, they will still be able to vote until they are slashed.\r\n     * @param amount new bondAmount.\r\n     */\r\n    function changeBondAmount(uint256 amount) external;\r\n\r\n    /**\r\n     * @dev change numKeepers to a new value. If numKeepers is being reduced, this will not remove any keepers, nor will it change orchestrator requirements.\r\n        However, it will render keeper licenses > maxNumKeepers invalid and their votes will stop counting.\r\n     */\r\n    function changeMaxKeepers(uint16 newNumKeepers) external;\r\n}\r\n"
    },
    "contracts/KeeperRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ArraysUpgradeable.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport { IKeeperRegistry } from \"./interfaces/IKeeperRegistry.sol\";\r\n\r\n/**\r\n * @dev owned by governance contract\r\n */\r\ncontract KeeperRegistry is\r\n    Initializable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable,\r\n    IKeeperRegistry\r\n{\r\n    using SafeERC20 for IERC20;\r\n    uint256 public maxNumKeepers; // Max # of keepers to allow at a time\r\n    uint256 public currentNumKeepers; // Current # of keepers.\r\n\r\n    // Bond token\r\n    IERC20 public bondCoin; // ERC20 token used to provide bonds. Meant to be Steer token.\r\n    uint256 public bondAmount; // Amount of bondCoin required to become a keeper\r\n    uint256 public freeCoin; // Amount of bondCoin no longer affiliated with any keeper (due to slashing etc.)\r\n\r\n    /**\r\n     * Slash safety period--if a keeper leaves, this is the amount of time (in seconds) they must \r\n        wait before they can withdraw their bond.\r\n     */\r\n    uint256 public transferDelay;\r\n\r\n    mapping(uint256 => address) public keeperLicenses; // This mapping is pretty much just used to track which licenses are free.\r\n    mapping(address => WorkerDetails) public registry; // Registry of keeper info for keepers and former keepers.\r\n\r\n    function initialize(\r\n        address coinAddress,\r\n        uint256 keeperTransferDelay,\r\n        uint256 maxKeepers,\r\n        uint256 bondSize\r\n    ) public initializer {\r\n        __UUPSUpgradeable_init();\r\n        __Ownable_init();\r\n        bondCoin = IERC20(coinAddress);\r\n        transferDelay = keeperTransferDelay;\r\n        maxNumKeepers = maxKeepers;\r\n        require(bondSize > 0, \"SIZE\");\r\n        bondAmount = bondSize;\r\n    }\r\n\r\n    function _authorizeUpgrade(address) internal override onlyOwner {}\r\n\r\n    /**\r\n     * @dev setup utility function for owner to add initial keepers. Addresses must each be unique and not hold any bondToken.\r\n     * @param joiners array of addresses to become keepers.\r\n     * note that this function will pull bondToken from the owner equal to bondAmount * numJoiners.\r\n     * note that this function assumes that the keeper registry currently has no keepers. It will revert if this assumption fails.\r\n     */\r\n    function joiningForOwner(address[] calldata joiners) public onlyOwner {\r\n        // Cache last license index\r\n        uint256 lastKeeperLicense = joiners.length + 1;\r\n\r\n        // Cache bond amount\r\n        uint256 _bondAmount = bondAmount;\r\n\r\n        bondCoin.safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            _bondAmount * joiners.length\r\n        );\r\n\r\n        // Ensure not too many keepers are being added.\r\n        require(joiners.length <= maxNumKeepers, \"MAX_KEEPERS\");\r\n\r\n        // Add each keeper to the registry\r\n        for (uint256 i = 1; i != lastKeeperLicense; ++i) {\r\n            // Make sure license is not already claimed by another keeper\r\n            require(keeperLicenses[i] == address(0), \"Address not new.\");\r\n\r\n            // Register keeper to license\r\n            keeperLicenses[i] = joiners[i - 1];\r\n\r\n            // Register license (and other info) to keeper\r\n            registry[joiners[i - 1]] = WorkerDetails({\r\n                bondHeld: _bondAmount,\r\n                licenseNumber: i,\r\n                leaveTimestamp: 0\r\n            });\r\n        }\r\n\r\n        currentNumKeepers += joiners.length;\r\n    }\r\n\r\n    /**\r\n     * @param amount Amount of bondCoin to be deposited.\r\n     * @dev this function has three uses:\r\n        1. If the caller is a keeper, they can increase their bondHeld by amount. This helps to avoid slashing.\r\n        2. If the caller is not a keeper or former keeper, they can attempt to claim a keeper license and become a keeper.\r\n        3. If the caller is a former keeper, they can attempt to cancel their leave request, claim a keeper license, and become a keeper.\r\n        In all 3 cases registry[msg.sender].bondHeld is increased by amount. In the latter 2, msg.sender's bondHeld after the transaction must be >= bondAmount.\r\n     */\r\n    function join(uint256 licenseNumber, uint256 amount) public {\r\n        // Transfer in bond.\r\n        if (amount > 0) {\r\n            bondCoin.safeTransferFrom(msg.sender, address(this), amount);\r\n        }\r\n\r\n        // Look up msg.sender in the mapping\r\n        WorkerDetails memory _workerDetails = registry[msg.sender];\r\n\r\n        if (_workerDetails.licenseNumber > 0) {\r\n            // If they have a license, they're a keeper, and amount will go towards their bondHeld\r\n            // If maxNumKeepers was decreased, they may not be a keeper, but this won't cause anything to break.\r\n            registry[msg.sender].bondHeld = _workerDetails.bondHeld + amount;\r\n        } else {\r\n            /*\r\n                Two scenarios here:\r\n                1. If their bondAmount is zero and their leaveTimestamp is zero, they are not yet a keeper, so this is a new address attempting to become a keeper.\r\n                2. If they are queued to leave but have not yet left, they are not a keeper, so this will cancel their leave request (by zeroing out leaveTimestamp) \r\n                and attempt to make them a keeper.\r\n                Either way the solution is the same -- if their new bondAmount is enough, they become a keeper with no leave date. Otherwise, this function reverts.\r\n            */\r\n\r\n            // Make sure requested license is valid and available\r\n            require(\r\n                keeperLicenses[licenseNumber] == address(0),\r\n                \"License not available.\"\r\n            );\r\n            require(licenseNumber > 0, \"LICENSE_NUMBER\");\r\n            require(licenseNumber <= maxNumKeepers, \"LICENSE_NUMBER\");\r\n\r\n            // Join must be sufficient to become a keeper\r\n            uint256 newBondAmount = _workerDetails.bondHeld + amount;\r\n            require(newBondAmount >= bondAmount, \"Insufficient bond amount.\");\r\n\r\n            ++currentNumKeepers;\r\n\r\n            // Register license/bond amount with keeper\r\n            registry[msg.sender] = WorkerDetails({\r\n                bondHeld: newBondAmount,\r\n                licenseNumber: licenseNumber,\r\n                leaveTimestamp: 0\r\n            });\r\n\r\n            // Register keeper with license\r\n            keeperLicenses[licenseNumber] = msg.sender;\r\n\r\n            emit PermissionChanged(msg.sender, permissionType.FULL);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Allows keepers to queue to leave the registry. Their elevated permissions are immediately revoked, and their funds can be retrieved once the transferDelay has passed.\r\n     * note that this function can only be called by keepers (or, in rare cases, former keepers whose licenses were revoked by a decrease in maxNumKeepers)\r\n     * emits a permissionChanged event if the call succeeds.\r\n     */\r\n    function queueToLeave() public {\r\n        WorkerDetails memory _workerDetails = registry[msg.sender];\r\n        require(\r\n            _workerDetails.licenseNumber > 0,\r\n            \"msg.sender is already not a keeper.\"\r\n        );\r\n\r\n        // Remove permissions immediately. Keeper can remove funds once the transferDelay has passed. This ensures that keeper can be slashed if they misbehaved just before leaving.\r\n        registry[msg.sender] = WorkerDetails({\r\n            bondHeld: _workerDetails.bondHeld,\r\n            licenseNumber: 0,\r\n            leaveTimestamp: block.timestamp + transferDelay\r\n        });\r\n        delete keeperLicenses[_workerDetails.licenseNumber];\r\n\r\n        // Decrease numKeepers count\r\n        --currentNumKeepers;\r\n\r\n        emit PermissionChanged(msg.sender, permissionType.NONE);\r\n    }\r\n\r\n    /**\r\n     * @dev addresses call this after they have queued to leave and waited the requisite amount of time.\r\n     */\r\n    function leave() external {\r\n        WorkerDetails memory info = registry[msg.sender];\r\n\r\n        // Validate leave request\r\n        require(info.leaveTimestamp > 0, \"Not queued to leave.\");\r\n        require(\r\n            info.leaveTimestamp < block.timestamp,\r\n            \"Transfer delay not passed.\"\r\n        );\r\n\r\n        // Send former keeper their previously staked tokens\r\n        bondCoin.safeTransfer(msg.sender, info.bondHeld);\r\n\r\n        // Reset the former keeper's data\r\n        delete registry[msg.sender];\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if the given address has the power to vote, reverts otherwise. This function is built to be called by the orchestrator.\r\n     * @param targetAddress address to check\r\n     * @return licenseNumber true if the given address has the power to vote, reverts otherwise.\r\n     */\r\n    function checkLicense(address targetAddress)\r\n        public\r\n        view\r\n        returns (uint256 licenseNumber)\r\n    {\r\n        licenseNumber = registry[targetAddress].licenseNumber;\r\n        require(licenseNumber > 0, \"NOT_A_KEEPER\");\r\n    }\r\n\r\n    /**\r\n     * @dev slashes a keeper, removing their permissions and forfeiting their bond.\r\n     * @param targetKeeper keeper to denounce\r\n     * @param amount amount of bondCoin to slash\r\n     * note that the keeper will only lose their license if, post-slash, their bond held is less than bondAmount.\r\n     */\r\n    function denounce(address targetKeeper, uint256 amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        WorkerDetails memory _workerDetails = registry[targetKeeper];\r\n\r\n        // Remove bondCoin from keeper who is being denounced, add to freeCoin (to be withdrawn by owner)\r\n        uint256 currentBondHeld = _workerDetails.bondHeld;\r\n\r\n        // If slash amount is greater than keeper's held bond, just slash 100% of their bond\r\n        if (currentBondHeld < amount) {\r\n            amount = currentBondHeld;\r\n        }\r\n\r\n        // Slash keeper's bond by amount\r\n        uint256 newBond = currentBondHeld - amount;\r\n        registry[targetKeeper].bondHeld = newBond;\r\n\r\n        // Add keeper's slashed bond tokens to freeCoin\r\n        freeCoin += amount;\r\n\r\n        // Remove user as keeper if they are below threshold, and are a keeper\r\n        if (newBond < bondAmount && _workerDetails.licenseNumber > 0) {\r\n            keeperLicenses[_workerDetails.licenseNumber] = address(0);\r\n            registry[targetKeeper].licenseNumber = 0;\r\n            --currentNumKeepers;\r\n        }\r\n\r\n        emit PermissionChanged(msg.sender, permissionType.SLASHED);\r\n    }\r\n\r\n    /**\r\n     * @dev withdraws slashed tokens from the vault and sends them to targetAddress.\r\n     * @param amount amount of bondCoin to withdraw\r\n     * @param targetAddress address receiving the tokens\r\n     */\r\n    function withdrawFreeCoin(uint256 amount, address targetAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        freeCoin -= amount;\r\n        bondCoin.safeTransfer(targetAddress, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev change bondAmount to a new value.\r\n     * @dev Does not change existing keeper permissions. If the bondAmount is being increased, existing keepers will not be slashed or removed. \r\n            note, they will still be able to vote until they are slashed.\r\n     * @param amount new bondAmount.\r\n     */\r\n    function changeBondAmount(uint256 amount) external onlyOwner {\r\n        bondAmount = amount;\r\n    }\r\n\r\n    /**\r\n     * @dev change numKeepers to a new value. If numKeepers is being reduced, this will not remove any keepers, nor will it change orchestrator requirements.\r\n        However, it will render keeper licenses > maxNumKeepers invalid and their votes will stop counting.\r\n     */\r\n    function changeMaxKeepers(uint16 newNumKeepers) external onlyOwner {\r\n        maxNumKeepers = newNumKeepers;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ArraysUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary ArraysUpgradeable {\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}\n"
    },
    "contracts/RunnerRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"./KeeperRegistry.sol\";\r\n\r\n// ERC20\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n// Proxy Support\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\ncontract RunnerRegistry is Initializable, UUPSUpgradeable, OwnableUpgradeable {\r\n    // Runner info\r\n    mapping(address => uint256) public runners;\r\n\r\n    // Bonds\r\n    uint256 public bondAmount; // Amount of bondcoin needed to qualify as a keeper\r\n    IERC20 public bondToken; // Address of ERC20 used as bond\r\n    uint256 public freeCoin; // Amount of bondcoin no longer affiliated with any runner (due to slashing etc.)\r\n\r\n    // Slashing\r\n    KeeperRegistry public keeperRegistry;\r\n\r\n    event RunnerAmountChanged(address indexed runner, int256 amount);\r\n\r\n    function initialize(\r\n        address _keeperRegistry,\r\n        uint256 _bondAmount,\r\n        address _bondToken\r\n    ) public initializer {\r\n        __UUPSUpgradeable_init();\r\n        __Ownable_init();\r\n        keeperRegistry = KeeperRegistry(_keeperRegistry);\r\n        bondAmount = _bondAmount;\r\n        bondToken = IERC20(_bondToken);\r\n    }\r\n\r\n    /// @dev Check whether an address is runner or not.\r\n    /// @param _runner is the address that needs to be checked.\r\n    /// @return True if address is a runner ,if not returns false.\r\n    function isRunner(address _runner) external view returns (bool) {\r\n        return runners[_runner] >= bondAmount;\r\n    }\r\n\r\n    /// @dev Used to bond as a runner\r\n    /// @param _amount is the amount of tokens that will be locked as bond amount.\r\n    function bond(uint256 _amount) external {\r\n        // Make sure the minimum bond is always met\r\n        // if it is met, then allow any amount to be sent\r\n        uint256 currentBonded = runners[msg.sender];\r\n        require(\r\n            currentBonded + _amount >= bondAmount,\r\n            \"Bonded amount must be above the minimum\"\r\n        );\r\n\r\n        // Record the total amount the runner has deposited\r\n        runners[msg.sender] = currentBonded + _amount;\r\n\r\n        emit RunnerAmountChanged(msg.sender, int256(_amount));\r\n        // Transfer the bond amount to the registry\r\n        bondToken.transferFrom(msg.sender, address(this), _amount);\r\n    }\r\n\r\n    /// @dev Used to unbond as a runner and get the bonded tokens back.\r\n    /// @param _amount is the amount of tokens that will be unlocked from bond amount.\r\n    function unbond(uint256 _amount) external {\r\n        runners[msg.sender] -= _amount;\r\n\r\n        emit RunnerAmountChanged(msg.sender, int256(_amount) * -1);\r\n        bondToken.transfer(msg.sender, _amount);\r\n    }\r\n\r\n    /// @dev Used to slash runners if they do a bad/malicious job.\r\n    /// Only keepers can slash runners.\r\n    /// @param _runner is the address of the runner who should be slashed.\r\n    /// @param _amount is the amount which should be slashed from the runner's bond amount.\r\n    function slash(address _runner, uint256 _amount) external {\r\n        keeperRegistry.checkLicense(msg.sender);\r\n        runners[_runner] -= _amount;\r\n        freeCoin += _amount;\r\n        emit RunnerAmountChanged(msg.sender, int256(_amount) * -1);\r\n    }\r\n\r\n    function _authorizeUpgrade(address) internal override onlyOwner {}\r\n\r\n    /// @dev Used to withdraw the tokens that were slashed from runners doing a bad/malicious job.\r\n    /// Can only be called by the owner of this contract.\r\n    /// @param _amount is the amount of tokens that needs to be withdrawn.\r\n    function withdrawFreeCoin(uint256 _amount) external onlyOwner {\r\n        freeCoin -= _amount;\r\n        bondToken.transfer(msg.sender, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/RewardOrchestrator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"./KeeperRegistry.sol\";\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"./interfaces/IRewardOrchestrator.sol\";\r\nimport \"./interfaces/IRunnerRewarder.sol\";\r\n\r\ncontract RewardOrchestrator is\r\n    IRewardOrchestrator,\r\n    Initializable,\r\n    UUPSUpgradeable,\r\n    OwnableUpgradeable\r\n{\r\n    uint256 public constant actionThresholdPercent = 51;\r\n\r\n    KeeperRegistry public keeperRegistry;\r\n    IRunnerRewarder public rewardTree;\r\n\r\n    // First index of hash mapping which is not yet occupied by a hash. This index is where the next proposed hash will be stored to be voted upon.\r\n    uint256 public firstEmptyHashIndex;\r\n\r\n    // Mapping hashIndex => hash\r\n    mapping(uint256 => bytes32) public hashChangeRequests;\r\n\r\n    // Mapping of hash votes\r\n    mapping(uint256 => uint256) public voteBitmaps;\r\n\r\n    // The index of the hash which was approved most recently; i.e. the current hash. No hash older (i.e. proposed earlier) than the current hash may be accepted.\r\n    uint256 public lastExecutedHashId;\r\n\r\n    modifier onlyKeeper() {\r\n        // This function reverts if msg.sender is not a keeper\r\n        keeperRegistry.checkLicense(_msgSender());\r\n        _;\r\n    }\r\n\r\n    function initialize(address _keeperRegistry, address _RunnerRewarder)\r\n        public\r\n        initializer\r\n    {\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n        rewardTree = IRunnerRewarder(_RunnerRewarder);\r\n        keeperRegistry = KeeperRegistry(_keeperRegistry);\r\n    }\r\n\r\n    function _authorizeUpgrade(address) internal override onlyOwner {}\r\n\r\n    /**\r\n     * @dev vote (if you are a keeper) on a given action proposal\r\n     * @param _hashId is the hash of the action to be voted on\r\n     * @param vote is the vote to be cast. false: reject, true: approve. false only has an effect if the keeper previously voted true. It resets their vote to false.\r\n     */\r\n    function voteOnHashChangeRequest(uint256 _hashId, bool vote) public {\r\n        // Get voter keeper license, use to construct bitmap\r\n        uint256 license = keeperRegistry.checkLicense(msg.sender);\r\n        uint256 bitmap = 1 << license;\r\n        if (vote) {\r\n            // Add vote to bitmap through AND\r\n            voteBitmaps[_hashId] |= bitmap;\r\n        } else {\r\n            // Remove vote from bitmap through XOR\r\n            voteBitmaps[_hashId] ^= bitmap;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if an action with given `actionId` is approved by all existing members of the group.\r\n     * Its up to the contract creators to decide if this method should look at majority votes (based on ownership)\r\n     * or if it should ask consent of all the users irrespective of their ownerships.\r\n     */\r\n    function actionApprovalStatus(uint256 _hash) public view returns (bool) {\r\n        uint256 maxLicenseId = keeperRegistry.maxNumKeepers() + 1;\r\n        uint256 yesVotes;\r\n        uint256 voteDifference;\r\n        uint256 voteBitmap = voteBitmaps[_hash];\r\n        for (uint256 i = 1; i != maxLicenseId; ++i) {\r\n            voteDifference = 1 << i;\r\n\r\n            if (voteBitmap & voteDifference == voteDifference) {\r\n                ++yesVotes;\r\n            }\r\n        }\r\n\r\n        uint256 numKeepers = keeperRegistry.currentNumKeepers();\r\n        // If there happen to be no keepers, div by zero error will happen here, preventing actions from being executed.\r\n        if ((yesVotes * 100) / numKeepers >= actionThresholdPercent) {\r\n            return true;\r\n        } else return (false);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a proposal to change the reward merkle tree hash to a new hash.\r\n     * @param _hash The new proposed merkle root hash\r\n     */\r\n    function createHashChangeRequest(bytes32 _hash)\r\n        external\r\n        onlyKeeper\r\n        returns (uint256)\r\n    {\r\n        // Cache current hashId\r\n        uint256 hashId = firstEmptyHashIndex;\r\n\r\n        // Store proposed hash in hashChangeRequests\r\n        hashChangeRequests[hashId] = _hash;\r\n\r\n        // Vote for the hash change request\r\n        voteOnHashChangeRequest(hashId, true);\r\n\r\n        // Increment the first empty hash index\r\n        firstEmptyHashIndex = hashId + 1;\r\n\r\n        // Return hashId of the new hash change request\r\n        return hashId;\r\n    }\r\n\r\n    /**\r\n     * @dev Use this function to execute a hash change request/propsal.\r\n     * @param _hashId is the ID of the hash change request.\r\n     * @return newState the state of the hash change request.\r\n     */\r\n    function executeHashChangeRequest(uint256 _hashId)\r\n        external\r\n        onlyKeeper\r\n        returns (State newState)\r\n    {\r\n        //Require that we're not reverting to a previous hash. Technically the 0th hash can be executed multiple times\r\n        // (if another hasn't been approved since) which isn't really a security concern--all it does is emit a useless event.\r\n        require(\r\n            _hashId > lastExecutedHashId || lastExecutedHashId == 0,\r\n            \"HashId should be greater than lastExecutedHashId\"\r\n        );\r\n\r\n        bool actionApproved = actionApprovalStatus(_hashId);\r\n        if (actionApproved) {\r\n            // If hash is approved\r\n            // This hash is now the most recent hash, so older hashes are rendered invalid\r\n            lastExecutedHashId = _hashId;\r\n\r\n            // Set reward merkle tree to new hash\r\n            bytes32 newHash = hashChangeRequests[_hashId];\r\n            emit ExecutedHashChangeRequest(_hashId, newHash);\r\n            rewardTree.changeMerkleRootHash(newHash);\r\n            return State.COMPLETED;\r\n        } else revert(\"Votes lacking; state still pending\");\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IRewardOrchestrator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\ninterface IRewardOrchestrator {\r\n    enum State {\r\n        PENDING,\r\n        COMPLETED\r\n    }\r\n\r\n    /// @dev Triggered when a hash change request/proposal is executed.\r\n    event ExecutedHashChangeRequest(uint256 indexed requestId, bytes32 hash);\r\n\r\n    function actionApprovalStatus(uint256 _hashId)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function createHashChangeRequest(bytes32 _hash) external returns (uint256);\r\n\r\n    function voteOnHashChangeRequest(uint256 _hashId, bool vote) external;\r\n\r\n    function executeHashChangeRequest(uint256 _hashId)\r\n        external\r\n        returns (State);\r\n}\r\n"
    },
    "contracts/interfaces/IRunnerRewarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\ninterface IRunnerRewarder {\r\n    /// @dev Emitted after a successful token claim\r\n    /// @param to recipient of claim\r\n    /// @param amount of tokens claimed\r\n    event Claim(address indexed to, uint256 amount);\r\n\r\n    function setRewardOrchestrator(address _rewardOrchestrator) external;\r\n\r\n    /**\r\n     * @param hash -- proposed new merkle root hash.\r\n     */\r\n    function changeMerkleRootHash(bytes32 hash) external;\r\n\r\n    function claim(uint256 amount, bytes32[] calldata proof) external;\r\n}\r\n"
    },
    "contracts/RunnerRewarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"./interfaces/IRewardOrchestrator.sol\";\r\nimport \"./interfaces/IRunnerRewarder.sol\";\r\n\r\ncontract RunnerRewarder is\r\n    IRunnerRewarder,\r\n    Initializable,\r\n    UUPSUpgradeable,\r\n    OwnableUpgradeable\r\n{\r\n    /// @dev ERC20-claimee inclusion root\r\n    bytes32 public merkleRoot;\r\n    address public rewardOrchestrator;\r\n    IERC20Upgradeable public rewardToken; //Token given as the reward\r\n\r\n    /// @dev Mapping of cumulative amount claimed by each address.\r\n    mapping(address => uint256) public claimed;\r\n\r\n    modifier onlyRewardOrchestrator() {\r\n        require(\r\n            msg.sender == rewardOrchestrator,\r\n            \"You are not permitted to call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function initialize(address _rewardTokenAddress) public initializer {\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n        rewardToken = IERC20Upgradeable(_rewardTokenAddress);\r\n    }\r\n\r\n    function _authorizeUpgrade(address) internal override onlyOwner {}\r\n\r\n    /// @dev Allows to set the rewardOrchestrator contract.\r\n    /// @dev Can only be called by owner of this contract.\r\n    /// @param _rewardOrchestrator address of the rewardOrchestrator contract.\r\n    function setRewardOrchestrator(address _rewardOrchestrator)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_rewardOrchestrator != address(0), \"Zero address, Invalid!\");\r\n        rewardOrchestrator = _rewardOrchestrator;\r\n    }\r\n\r\n    /// @dev Allow to change the merkle root hash stored on this contract\r\n    /// @dev rewardOrchestrator is the contract which is only address capable of changing merkle hash in this contract\r\n    /// @param hash is the new merkle root hash.\r\n    function changeMerkleRootHash(bytes32 hash)\r\n        external\r\n        onlyRewardOrchestrator\r\n    {\r\n        merkleRoot = hash;\r\n    }\r\n\r\n    /// @dev Allows claiming tokens if hash made from address and amount is part of the merkle tree\r\n    /// @param amount of total tokens earned by claimee. Note that this includes previously claimed tokens.\r\n    /// @param proof merkle proof to prove address and amount are in tree\r\n    function claim(uint256 amount, bytes32[] calldata proof) external {\r\n        uint256 claimedTillNow = claimed[msg.sender];\r\n        require(\r\n            amount > claimedTillNow,\r\n            \"This amount has already been claimed\"\r\n        );\r\n\r\n        // Verify merkle proof, or revert if not in tree\r\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount));\r\n        bool isValidLeaf = MerkleProofUpgradeable.verify(\r\n            proof,\r\n            merkleRoot,\r\n            leaf\r\n        );\r\n        require(isValidLeaf, \"Calculated Merkle Hash is invalid\");\r\n\r\n        //Set claimed equal to amount, to prevent double-claiming\r\n        claimed[msg.sender] = amount;\r\n\r\n        // Emit claim event\r\n        emit Claim(msg.sender, amount - claimedTillNow);\r\n\r\n        // Transfer reward tokens to the claimer\r\n        rewardToken.transfer(msg.sender, amount - claimedTillNow);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProofUpgradeable {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n"
    },
    "contracts/DynamicJobs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport { IDynamicJobs } from \"./interfaces/IDynamicJobs.sol\";\r\nimport { IKeeperRegistry } from \"./interfaces/IKeeperRegistry.sol\";\r\nimport { IGasVault } from \"./interfaces/IGasVault.sol\";\r\nimport { IOrchestrator } from \"./interfaces/IOrchestrator.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\ncontract DynamicJobs is Initializable, OwnableUpgradeable, IDynamicJobs {\r\n    // Storage\r\n\r\n    address public keeperRegistry;\r\n    address public orchestrator;\r\n    address public creator;\r\n    uint256 public gasBalance;\r\n    address public gasVault;\r\n\r\n    /// @dev The mapping of jobState has 3 possibilities\r\n    ///      1) 0 means not registered\r\n    ///      2) 1 means registered and paused\r\n    ///      3) 2 means unpaused and registered (active)\r\n    mapping(bytes32 => uint256) public jobState;\r\n\r\n    // Constructor\r\n\r\n    constructor() {}\r\n\r\n    // External Functions\r\n\r\n    function initialize(\r\n        address _orchestrator,\r\n        address, // Steer multisig not used here\r\n        address, // Internal governance not used here\r\n        bytes calldata _params\r\n    ) external initializer {\r\n        address _creator = abi.decode(_params, (address));\r\n\r\n        // Fetch gas vault and keeper registry from orchestrator\r\n        keeperRegistry = IOrchestrator(_orchestrator).keeperRegistry();\r\n        gasVault = IOrchestrator(_orchestrator).gasVault();\r\n\r\n        __Ownable_init();\r\n        creator = _creator;\r\n        orchestrator = _orchestrator;\r\n    }\r\n\r\n    /// @dev Use this function to register jobs.\r\n    /// @param _userProvidedData The calldatas that are provided by the user at the registration time.\r\n    /// @param _targetAddresses The addresses of the contracts on which the jobs need to be executed.\r\n    /// @param _name The name of the job.\r\n    /// @param _ipfsForJobDetails The ipfs hash containing job details like the interval for job execution.\r\n    function registerJob(\r\n        bytes[] calldata _userProvidedData,\r\n        address[] calldata _targetAddresses,\r\n        string calldata _name,\r\n        string calldata _ipfsForJobDetails\r\n    ) external {\r\n        // Validate param length\r\n        require(\r\n            _userProvidedData.length == _targetAddresses.length,\r\n            \"Wrong Address Count\"\r\n        );\r\n\r\n        // Only vault owner can register jobs for this vault\r\n        require(creator == msg.sender, \"Unauthorized\");\r\n\r\n        // Record job hash\r\n        bytes32 jobHash = keccak256(\r\n            abi.encode(_userProvidedData, _targetAddresses)\r\n        );\r\n        // Job is currently unpaused\r\n        jobState[jobHash] = 2;\r\n\r\n        // Emit job details so that they can be used offchain\r\n        emit JobRegistered(\r\n            _userProvidedData,\r\n            _targetAddresses,\r\n            jobHash,\r\n            _name,\r\n            _ipfsForJobDetails\r\n        );\r\n    }\r\n\r\n    /// @dev Use this function to register jobs and deposit gas in one call\r\n    ///      Send the amount of gas that is needed to be deposited as msg.value.\r\n    /// @param _userProvidedData The calldatas that are provided by the user at the registration time.\r\n    /// @param _targetAddresses The addresses of the contracts on which the jobs need to be executed.\r\n    /// @param _name The name of the job.\r\n    /// @param _ipfsForJobDetails The ipfs hash containing job details like the interval for job execution.\r\n    function registerJobAndDepositGas(\r\n        bytes[] calldata _userProvidedData,\r\n        address[] calldata _targetAddresses,\r\n        string calldata _name,\r\n        string calldata _ipfsForJobDetails\r\n    ) external payable {\r\n        // Register job\r\n        require(\r\n            _userProvidedData.length == _targetAddresses.length,\r\n            \"Wrong Address Count\"\r\n        );\r\n        require(creator == msg.sender, \"Unauthorized\");\r\n        bytes32 jobHash = keccak256(\r\n            abi.encode(_userProvidedData, _targetAddresses)\r\n        );\r\n        jobState[jobHash] = 2;\r\n        emit JobRegistered(\r\n            _userProvidedData,\r\n            _targetAddresses,\r\n            jobHash,\r\n            _name,\r\n            _ipfsForJobDetails\r\n        );\r\n\r\n        // Deposit gas\r\n        IGasVault(gasVault).deposit{ value: msg.value }(address(this));\r\n    }\r\n\r\n    /// @dev Use this function to execute Jobs.\r\n    ///      Only Orchestrator can call this function.\r\n    /// @param _calldatas The calldatas that are provided by the user at the registration time.\r\n    /// @param _timeIndependentLengths The encoded parameters sent at the time of creation\r\n    ///                 or execution of action in orchestrator according to the strategy.\r\n    /// @param _targetAddresses The addresses of the contracts on which the jobs need to be executed.\r\n    function executeJob(\r\n        address[] calldata _targetAddresses,\r\n        bytes[] calldata _calldatas,\r\n        uint256[] calldata _timeIndependentLengths\r\n    ) external {\r\n        // Make sure this action is approved and has not yet been executed\r\n        bytes32 _jobHash;\r\n        if (_timeIndependentLengths.length == 0) {\r\n            // If none of the data is time-sensitive, just use passed in calldatas\r\n            _jobHash = keccak256(abi.encode(_calldatas, _targetAddresses));\r\n        } else {\r\n            // If some of it is time-sensitive, create a new array using timeIndependentLengths to represent what was originally passed in, then compare that hash instead\r\n            uint256 numCalldatas = _timeIndependentLengths.length;\r\n\r\n            // Construct original calldatas\r\n            bytes[] memory timeIndependentCalldatas = new bytes[](\r\n                numCalldatas\r\n            );\r\n            for (uint256 i; i != numCalldatas; ++i) {\r\n                timeIndependentCalldatas[i] = _calldatas[\r\n                    i\r\n                ][:_timeIndependentLengths[i]];\r\n            }\r\n\r\n            // Create hash from sliced calldatas\r\n            _jobHash = keccak256(\r\n                abi.encode(timeIndependentCalldatas, _targetAddresses)\r\n            );\r\n        }\r\n        // Ensure passed params match user registered job\r\n        require(jobState[_jobHash] == 2, \"Paused or Not Registered\");\r\n        // Ensure that job is not paused\r\n        require(msg.sender == orchestrator, \"Unauthorized\");\r\n        uint256 joblength = _targetAddresses.length;\r\n        for (uint256 i; i != joblength; ++i) {\r\n            (bool success, ) = _targetAddresses[i].call(_calldatas[i]);\r\n            // Revert if this method failed, thus reverting all methods in this job\r\n            require(success);\r\n        }\r\n        emit JobExecuted(_jobHash, msg.sender);\r\n    }\r\n\r\n    /// @dev Use this function to pause or unpause a job\r\n    /// @param _jobHash The keccak of encoded parameters and target addresses\r\n    /// @param _toggle Value to pause or unpause the job\r\n    ///                Pass 1 to pause the job and pass 2 to unpause the job\r\n    function toggleForCreator(bytes32 _jobHash, uint256 _toggle) external {\r\n        require(creator == msg.sender, \"Access Denied\");\r\n        require(_toggle == 1 || _toggle == 2, \"Invalid\");\r\n        jobState[_jobHash] = _toggle;\r\n        emit JobToggledByCreator(_jobHash, _toggle);\r\n    }\r\n\r\n    /// @dev Use this function to withdraw gas associated to this vault\r\n    ///      Only creator of this vault can call this function\r\n    /// @param _amount The amount of ether in wei that creator of this contract wants to pull out\r\n    /// @param to The address at which the creator wants to pull the deposited ether out\r\n    function withdrawGas(uint256 _amount, address to) external {\r\n        require(msg.sender == creator, \"Not Creator\");\r\n        IGasVault(gasVault).withdraw(_amount, to);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IDynamicJobs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\ninterface IDynamicJobs {\r\n    event JobExecuted(bytes32 jobHash, address executor);\r\n    event JobRegistered(\r\n        bytes[] jobInfo,\r\n        address[] targetAddresses,\r\n        bytes32 jobHash,\r\n        string name,\r\n        string ipfsForJobDetails\r\n    );\r\n    event JobToggledByCreator(bytes32 jobHash, uint256 toggle);\r\n\r\n    function registerJob(\r\n        bytes[] calldata _userProvidedData,\r\n        address[] calldata _targetAddresses,\r\n        string calldata _name,\r\n        string calldata _ipfsForJobDetails\r\n    ) external;\r\n\r\n    function registerJobAndDepositGas(\r\n        bytes[] calldata _userProvidedData,\r\n        address[] calldata _targetAddresses,\r\n        string calldata _name,\r\n        string calldata _ipfsForJobDetails\r\n    ) external payable;\r\n\r\n    function executeJob(\r\n        address[] calldata _targetAddresses,\r\n        bytes[] calldata _calldatas,\r\n        uint256[] calldata _timeIndependentLengths\r\n    ) external;\r\n\r\n    function toggleForCreator(bytes32 _jobHash, uint256 _toggle) external;\r\n\r\n    function withdrawGas(uint256 _amount, address to) external;\r\n}\r\n"
    },
    "contracts/GasVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\nimport \"./interfaces/IGasVault.sol\";\r\nimport \"./interfaces/IOrchestrator.sol\";\r\nimport \"./interfaces/IStrategyRegistry.sol\";\r\nimport \"./interfaces/IVaultRegistry.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\n/**\r\n * @dev vault for storing gas for each strategy. Nodes must still pay gas cost to call, but execution costs\r\n *  will come out of the gas account.\r\n */\r\ncontract GasVault is\r\n    IGasVault,\r\n    Initializable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    // Storage\r\n\r\n    IOrchestrator public orchestrator;\r\n    IStrategyRegistry public strategyRegistry;\r\n    IVaultRegistry public vaultRegistry;\r\n    address public governance;\r\n\r\n    /// @notice Mapping from vault address to gasInfo\r\n    mapping(address => uint256) public ethBalances;\r\n\r\n    /// @dev Permanently sets related addresses\r\n    /// @param _orchestrator Address of the orchestrator contract\r\n    /// @param _stratRegistry Address of the strategy registry contract\r\n    /// @param _vaultRegistry Address of the vault registry contract\r\n    /// @param _governance Address of Steer governance contract\r\n    function initialize(\r\n        address _orchestrator,\r\n        address _stratRegistry,\r\n        address _vaultRegistry,\r\n        address _governance\r\n    ) public initializer {\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n        orchestrator = IOrchestrator(_orchestrator);\r\n        strategyRegistry = IStrategyRegistry(_stratRegistry);\r\n        vaultRegistry = IVaultRegistry(_vaultRegistry);\r\n        governance = _governance;\r\n    }\r\n\r\n    function _authorizeUpgrade(address) internal override onlyOwner {}\r\n\r\n    modifier onlyOrchestrator() {\r\n        require(\r\n            msg.sender == address(orchestrator),\r\n            \"Only orchestrator can call this\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        require(msg.sender == governance, \"Only governance can call this\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Deposit more eth to be used in jobs.\r\n    ///      Can only be withdrawn by governance and the given vault,\r\n    ///      so in most cases these funds are unretrievable.\r\n    /// @param targetAddress address of the recipient of these gas funds\r\n    function deposit(address targetAddress) external payable override {\r\n        ethBalances[targetAddress] += msg.value;\r\n        emit Deposited(msg.sender, targetAddress, msg.value);\r\n    }\r\n\r\n    /// @dev Withdraws eth from given vault. Can only be called by governance.\r\n    ///      Meant to be used for dead vaults and large amounts of mistakenly-deposited funds.\r\n    /// @param amount Amount of ETH to withdraw from given vault account\r\n    /// @param targetAddress Address to withdraw\r\n    function withdraw(\r\n        uint256 amount,\r\n        address targetAddress,\r\n        address to\r\n    ) external override onlyGovernance {\r\n        ethBalances[targetAddress] -= amount;\r\n        emit Withdrawn(targetAddress, to, amount);\r\n        payable(to).transfer(amount);\r\n    }\r\n\r\n    /// @dev Normal withdraw function, normally used by keepers\r\n    /// @param amount The amount to withdraw\r\n    /// @param to Address to send the ether to\r\n    function withdraw(uint256 amount, address to) external override {\r\n        ethBalances[msg.sender] -= amount;\r\n        emit Withdrawn(msg.sender, to, amount);\r\n        payable(to).transfer(amount);\r\n    }\r\n\r\n    /// @param targetAddress The address of the vault in question\r\n    /// @param highGasEstimate An estimate of the highest reasonable gas price which\r\n    ///                        a transaction will cost, in terms of wei.\r\n    ///                        In other words, given a bad gas price,\r\n    ///                        how many more times can a strategy be run.\r\n    /// @return transactions Remaining, assuming upper limit estimate of gas price\r\n    ///                      is used for the transaction\r\n    function transactionsRemaining(\r\n        address targetAddress,\r\n        uint256 highGasEstimate\r\n    ) external view override returns (uint256) {\r\n        IVaultRegistry.VaultData memory vaultInfo = vaultRegistry\r\n            .getVaultDetails(targetAddress);\r\n        IStrategyRegistry.RegisteredStrategy memory info = strategyRegistry\r\n            .getRegisteredStrategy(vaultInfo.tokenId);\r\n        if (highGasEstimate > info.maxGasCost) {\r\n            return 0;\r\n        } else {\r\n            uint256 totalWeiPerMethod = info.maxGasPerAction * highGasEstimate;\r\n            return ethBalances[targetAddress] / totalWeiPerMethod;\r\n        }\r\n    }\r\n\r\n    /// @dev Orchestrator calls this function in order to reimburse tx.origin for method gas.\r\n    ///      First it checks that all parameters are correct (gas price isn't too high),\r\n    ///      And then it returns as much gas as is available to use in the transaction.\r\n    ///      Note that this function will revert if the gas price is too high for the strategy.\r\n    ///      This should be checked by the keeper beforehand.\r\n    /// @param _targetAddress Address actions will be performed on, and address paying gas for those actions.\r\n    /// @return gasAvailable (representing amount of gas available per Method).\r\n    function gasAvailableForTransaction(address _targetAddress)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Get gas info\r\n        IVaultRegistry.VaultData memory vaultInfo = vaultRegistry\r\n            .getVaultDetails(_targetAddress);\r\n        IStrategyRegistry.RegisteredStrategy memory info = strategyRegistry\r\n            .getRegisteredStrategy(vaultInfo.tokenId);\r\n\r\n        // Ensure requested gas use is acceptable.\r\n        // wei / gas must be less than maxGasCost,\r\n        // and GasVault must have enough ether allotted to pay for action.\r\n        require(tx.gasprice <= info.maxGasCost, \"Gas too expensive.\");\r\n\r\n        // Represents gas available per action. Gas cost of all methods must be <= this.\r\n        uint256 gasAvailable = info.maxGasPerAction;\r\n        require(\r\n            ethBalances[_targetAddress] >= tx.gasprice * gasAvailable,\r\n            \"Insufficient ether deposited\"\r\n        );\r\n\r\n        // Return gas available\r\n        return gasAvailable;\r\n    }\r\n\r\n    /// @dev Note that keepers still have to pull their gas from the GasVault in order\r\n    ///      to truly be reimbursed--until then the ETH is just sitting in the GasVault.\r\n    /// @param targetAddress The address which the action was performed upon.\r\n    ///                      The reimbursement will come from its gas fund.\r\n    /// @param originalGas How much gas there was at the start of the action (before any action was called)\r\n    /// @param jobHash The hash of the job which was performed.\r\n    ///                All vaults other than DynamicJobs can only have one job,\r\n    ///                so in this case jobHash will just be actionHash.\r\n    function reimburseGas(\r\n        address targetAddress,\r\n        uint256 originalGas,\r\n        bytes32 jobHash\r\n    ) external onlyOrchestrator {\r\n        // Calculate reimbursement amount\r\n        uint256 gasUsed = originalGas - gasleft();\r\n        uint256 ethUsed = (gasUsed * tx.gasprice);\r\n\r\n        // Distribute funds\r\n        ethBalances[targetAddress] -= ethUsed;\r\n        unchecked {\r\n            ethBalances[tx.origin] += ethUsed;\r\n        }\r\n        emit EtherUsed(targetAddress, ethUsed, jobHash);\r\n    }\r\n}\r\n"
    },
    "contracts/SteerGovernanceTimelock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\ncontract SteerGovernanceTimelock is\r\n    Initializable,\r\n    TimelockControllerUpgradeable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n\r\n    constructor() initializer {}\r\n\r\n    function initialize(\r\n        uint256 minDelay,\r\n        address[] memory proposers,\r\n        address[] memory executors\r\n    ) public initializer {\r\n        __TimelockController_init(minDelay, proposers, executors);\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        override\r\n        onlyOwner\r\n    {}\r\n}\r\n"
    },
    "contracts/InternalGovernanceTimelock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\ncontract InternalGovernanceTimelock is\r\n    Initializable,\r\n    TimelockControllerUpgradeable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n\r\n    constructor() initializer {}\r\n\r\n    function initialize(\r\n        uint256 minDelay,\r\n        address[] memory proposers,\r\n        address[] memory executors\r\n    ) public initializer {\r\n        __TimelockController_init(minDelay, proposers, executors);\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        override\r\n        onlyOwner\r\n    {}\r\n}\r\n"
    },
    "contracts/InternalGovernance.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"./interfaces/IInternalGovernance.sol\";\r\n\r\ncontract InternalGovernance is\r\n    IInternalGovernance,\r\n    Initializable,\r\n    GovernorUpgradeable,\r\n    GovernorSettingsUpgradeable,\r\n    GovernorCompatibilityBravoUpgradeable,\r\n    GovernorVotesUpgradeable,\r\n    GovernorVotesQuorumFractionUpgradeable,\r\n    GovernorTimelockControlUpgradeable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    address private steerTimelock;\r\n    mapping(address => bool) public hasVotingPower;\r\n\r\n    constructor() initializer {}\r\n\r\n    function initialize(\r\n        ERC20VotesUpgradeable _token,\r\n        TimelockControllerUpgradeable _timelock,\r\n        address _steerTimeLock,\r\n        address[] memory _voters\r\n    ) public initializer {\r\n        __Governor_init(\"SteerGovernance\");\r\n        __GovernorSettings_init(\r\n            1, /* 1 block of voting delay*/\r\n            45818, /* 1 week of voting period*/\r\n            100e18 /* Voters need 100 tokens to vote */\r\n        );\r\n        __GovernorCompatibilityBravo_init();\r\n        __GovernorVotes_init(_token);\r\n        __GovernorVotesQuorumFraction_init(\r\n            40 /* 40% */\r\n        );\r\n        __GovernorTimelockControl_init(_timelock);\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n        steerTimelock = _steerTimeLock;\r\n        giveVotingPowerDuringDeployment(_voters);\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        override\r\n        onlyOwner\r\n    {}\r\n\r\n    function votingDelay()\r\n        public\r\n        view\r\n        override(IGovernorUpgradeable, GovernorSettingsUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        return super.votingDelay();\r\n    }\r\n\r\n    function votingPeriod()\r\n        public\r\n        view\r\n        override(IGovernorUpgradeable, GovernorSettingsUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        return super.votingPeriod();\r\n    }\r\n\r\n    function proposalThreshold()\r\n        public\r\n        view\r\n        override(GovernorUpgradeable, GovernorSettingsUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        return super.proposalThreshold();\r\n    }\r\n\r\n    function quorum(uint256 blockNumber)\r\n        public\r\n        view\r\n        override(IGovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        return super.quorum(blockNumber);\r\n    }\r\n\r\n    function getVotes(address account, uint256 blockNumber)\r\n        public\r\n        view\r\n        override(IGovernorUpgradeable, GovernorVotesUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        return super.getVotes(account, blockNumber);\r\n    }\r\n\r\n    function state(uint256 proposalId)\r\n        public\r\n        view\r\n        override(\r\n            GovernorUpgradeable,\r\n            IGovernorUpgradeable,\r\n            GovernorTimelockControlUpgradeable\r\n        )\r\n        returns (ProposalState)\r\n    {\r\n        return super.state(proposalId);\r\n    }\r\n\r\n    /**\r\n     * @dev propose a new governance action.\r\n     * @param targets the target address of each proposed action.\r\n     * @param values the ETH value of each proposed action.\r\n     * @param calldatas the calldata of each proposed action.\r\n     * @param description the description of this governance action.\r\n     */\r\n    function propose(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        string memory description\r\n    )\r\n        public\r\n        override(\r\n            GovernorUpgradeable,\r\n            GovernorCompatibilityBravoUpgradeable,\r\n            IGovernorUpgradeable\r\n        )\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            hasVotingPower[msg.sender] == true,\r\n            \"You don't have power to make proposal\"\r\n        );\r\n        return super.propose(targets, values, calldatas, description);\r\n    }\r\n\r\n    /**\r\n     * @dev propose a new governance action, with signatures from other signers\r\n     * @param targets the target address of each proposed action.\r\n     * @param signatures extra signatures for bravo governance\r\n     * @param values the ETH value of each proposed action.\r\n     * @param calldatas the calldata of each proposed action.\r\n     * @param description the description of this governance action.\r\n     */\r\n    function propose(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        string[] memory signatures,\r\n        bytes[] memory calldatas,\r\n        string memory description\r\n    )\r\n        public\r\n        override(GovernorCompatibilityBravoUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            hasVotingPower[msg.sender] == true,\r\n            \"You don't have power to make proposal\"\r\n        );\r\n        return\r\n            super.propose(targets, values, signatures, calldatas, description);\r\n    }\r\n\r\n    /*\r\n     * @dev vote on a proposal handler\r\n     * @param proposalId the ID of this proposal\r\n     * @param account account that is voting\r\n     * @param support is the vote being cast--0 for against, 1 for for, 2 for abstain.\r\n     * @param reason is the reason for the vote being cast.\r\n     * @dev call castVote to actually access this function.\r\n     */\r\n    function _castVote(\r\n        uint256 proposalId,\r\n        address account,\r\n        uint8 support,\r\n        string memory reason\r\n    ) internal override(GovernorUpgradeable) returns (uint256) {\r\n        require(\r\n            hasVotingPower[msg.sender] == true,\r\n            \"You don't have power to cast vote\"\r\n        );\r\n        return super._castVote(proposalId, account, support, reason);\r\n    }\r\n\r\n    function _execute(\r\n        uint256 proposalId,\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        bytes32 descriptionHash\r\n    )\r\n        internal\r\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\r\n    {\r\n        super._execute(\r\n            proposalId,\r\n            targets,\r\n            values,\r\n            calldatas,\r\n            descriptionHash\r\n        );\r\n    }\r\n\r\n    function _cancel(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        bytes32 descriptionHash\r\n    )\r\n        internal\r\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            hasVotingPower[msg.sender] == true,\r\n            \"You don't have power to cancel\"\r\n        );\r\n        return super._cancel(targets, values, calldatas, descriptionHash);\r\n    }\r\n\r\n    function _executor()\r\n        internal\r\n        view\r\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\r\n        returns (address)\r\n    {\r\n        return super._executor();\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override(\r\n            GovernorUpgradeable,\r\n            IERC165Upgradeable,\r\n            GovernorTimelockControlUpgradeable\r\n        )\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /// @dev Use this function to give the ability to vote in the proposals made in this contract.\r\n    /// @dev Only Steer Governance Timelock can call this function.\r\n    /// @param _recipients is the array of addresses that should be given the ability to vote.\r\n    function giveVotingPower(address[] memory _recipients) external {\r\n        require(msg.sender == steerTimelock);\r\n\r\n        uint256 recipientCount = _recipients.length;\r\n        for (uint256 i; i != recipientCount; ++i) {\r\n            hasVotingPower[_recipients[i]] = true;\r\n        }\r\n\r\n        emit VotingPowerGiven(_recipients);\r\n    }\r\n\r\n    function giveVotingPowerDuringDeployment(address[] memory _recipients)\r\n        internal\r\n    {\r\n        uint256 recipientCount = _recipients.length;\r\n        for (uint256 i; i != recipientCount; ++i) {\r\n            hasVotingPower[_recipients[i]] = true;\r\n        }\r\n\r\n        emit VotingPowerGiven(_recipients);\r\n    }\r\n\r\n    /// @dev Use this function to remove the ability to vote in the proposals made in this contract.\r\n    /// @dev Only Steer Governance Timelock can call this function.\r\n    /// @param _recipients is the array of addresses whose ability to vote should be removed.\r\n    function removeVotingPower(address[] memory _recipients) external {\r\n        require(msg.sender == steerTimelock);\r\n\r\n        uint256 recipientCount = _recipients.length;\r\n        for (uint256 i; i != recipientCount; ++i) {\r\n            hasVotingPower[_recipients[i]] = false;\r\n        }\r\n\r\n        emit VotingPowerRemoved(_recipients);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IInternalGovernance.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\ninterface IInternalGovernance {\r\n    event VotingPowerGiven(address[] recipients);\r\n    event VotingPowerRemoved(address[] recipients);\r\n\r\n    function giveVotingPower(address[] memory _recipients) external;\r\n\r\n    function removeVotingPower(address[] memory _recipients) external;\r\n}\r\n"
    },
    "contracts/BundleRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\n// Proxy Support\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport { IBundleRegistry } from \"./interfaces/IBundleRegistry.sol\";\r\n\r\ncontract BundleRegistry is\r\n    IBundleRegistry,\r\n    Initializable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable,\r\n    PausableUpgradeable\r\n{\r\n    // Storage\r\n\r\n    mapping(bytes32 => DataSourceAdapter) public bundles;\r\n\r\n    function initialize() public initializer {\r\n        __UUPSUpgradeable_init();\r\n        __Ownable_init();\r\n        __Pausable_init();\r\n    }\r\n\r\n    /// @dev Registers an execution bundle, making data accessible to nodes.\r\n    ///      Once registered, each bundle is immutable.\r\n    ///      Only the contract owner can change it, and they can only\r\n    ///      deactivate/reactivate it if necessary.\r\n    /// @param _bundle The bundle of the transformation module.\r\n    /// @param _source The source of the transformation module source (e.g. \"The Graph\" or \"Twitter\")\r\n    /// @param _host The host of the transformation module source (e.g. \"Uniswap\" or \"@random-twitter-username\")\r\n    /// @param _output The output type of the adapter, example: OHLC, OHLCV, SingleValue, etc.\r\n    /// @param _active Determines if the adapter is active or not, allows for inactive sources\r\n    ///                to be deprecated, vaults can pause based on this\r\n    function register(\r\n        string calldata _bundle,\r\n        string calldata _source,\r\n        string calldata _host,\r\n        string calldata _output,\r\n        bool _active\r\n    ) external whenNotPaused {\r\n        require(isIPFS(_bundle), \"Bundle must be an IPFS CID hash\");\r\n\r\n        bytes32 bundleHash = keccak256(\r\n            abi.encode(_bundle, _source, _host, _output)\r\n        );\r\n\r\n        // Check that bundle does not yet have an author--proxy\r\n        // to check whether the bundle was already registered.\r\n\r\n        require(\r\n            bundles[bundleHash].author == address(0),\r\n            \"Bundle already registered\"\r\n        );\r\n\r\n        // Record bundle\r\n        bundles[bundleHash] = DataSourceAdapter({\r\n            bundle: _bundle,\r\n            source: _source,\r\n            host: _host,\r\n            output: _output,\r\n            active: _active,\r\n            author: _msgSender()\r\n        });\r\n\r\n        // Emit the event that the bundle was created\r\n        emit BundleRegistered(\r\n            bundleHash,\r\n            _bundle,\r\n            _host,\r\n            _source,\r\n            _output,\r\n            _active,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        override\r\n        onlyOwner\r\n    {}\r\n\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    /// @dev onlyOwner function to deprecate (or reactivate) an existing adapter.\r\n    /// @param _adapter The key of the adapter to pause.\r\n    /// @param _remainActive Whether to pause or unpause; false to pause.\r\n    function pauseAdapter(bytes32 _adapter, bool _remainActive)\r\n        external\r\n        onlyOwner\r\n    {\r\n        bundles[_adapter].active = _remainActive;\r\n    }\r\n\r\n    /// @dev Checks if the passed string is a IPFS link or not.\r\n    /// @param source String that needs to checked.\r\n    /// @return true if the string passed is IPFS, else it will return false.\r\n    function isIPFS(string memory source) internal pure returns (bool) {\r\n        bytes memory sourceToBytes = bytes(source);\r\n        bytes memory firstChar = new bytes(1);\r\n        firstChar[0] = sourceToBytes[0];\r\n        return\r\n            keccak256(firstChar) == keccak256(bytes(\"Q\")) &&\r\n            sourceToBytes.length == 46;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IBundleRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\ninterface IBundleRegistry {\r\n    // Need to update contract!\r\n    // Data Source Adapter\r\n    // source: Source name, example: TheGraph\r\n    // host: Host url or ip, example: https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3\r\n    // output: The output type of the adapter, example: OHLC, OHLCV, SingleValue, etc.\r\n    // bundle: (cid example: QmVj...DAwMA)\r\n    // active: determines if the adapter is active or not, allows for inactive sources to be deprecated, vaults can pause based on this\r\n    struct DataSourceAdapter {\r\n        string bundle;\r\n        string source;\r\n        string host;\r\n        string output;\r\n        bool active;\r\n        address author;\r\n    }\r\n\r\n    event BundleRegistered(\r\n        bytes32 hash,\r\n        string bundle,\r\n        string host,\r\n        string source,\r\n        string output,\r\n        bool active,\r\n        address creator\r\n    );\r\n\r\n    /// @dev Registers an execution bundle, printing an NFT and mapping to execution bundle and host.\r\n    /// @param _bundle the bundle of the transformation module.\r\n    /// @param _source The host of the transformation module source (e.g. \"Uniswap\")\r\n    /// @param _host The host of the transformation module source (e.g. \"Uniswap\")\r\n    /// @param _output The output type of the adapter, example: OHLC, OHLCV, SingleValue, etc.\r\n    /// @param _active determines if the adapter is active or not, allows for inactive sources to be deprecated, vaults can pause based on this\r\n    function register(\r\n        string memory _bundle,\r\n        string memory _source,\r\n        string memory _host,\r\n        string memory _output,\r\n        bool _active\r\n    ) external;\r\n\r\n    /// @dev Pauses the registeration of bundles\r\n    function pause() external;\r\n}\r\n"
    },
    "contracts/TreasuryVester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\nimport { ITreasuryVester, ISteerToken } from \"./interfaces/ITreasuryVester.sol\";\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract TreasuryVester is ITreasuryVester {\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public immutable steerToken;\r\n    address public recipient;\r\n    address public owner;\r\n\r\n    uint256 public vestingAmount;\r\n    uint256 public vestingBegin;\r\n    uint256 public vestingCliff;\r\n    uint256 public vestingEnd;\r\n\r\n    uint256 public lastUpdate;\r\n\r\n    constructor(\r\n        address steerToken_,\r\n        address recipient_,\r\n        address _owner, // Intended to be multisig. This address can cut off funding if user leaves Steer.\r\n        uint256 vestingAmount_,\r\n        uint256 vestingBegin_,\r\n        uint256 vestingCliff_,\r\n        uint256 vestingEnd_\r\n    ) {\r\n        require(vestingCliff_ >= vestingBegin_, \"C\");\r\n        require(vestingEnd_ > vestingCliff_, \"E\");\r\n\r\n        steerToken = steerToken_;\r\n        recipient = recipient_;\r\n        owner = _owner;\r\n\r\n        vestingAmount = vestingAmount_;\r\n        vestingBegin = vestingBegin_;\r\n        vestingCliff = vestingCliff_;\r\n        vestingEnd = vestingEnd_;\r\n\r\n        lastUpdate = vestingBegin;\r\n    }\r\n\r\n    /// @dev Change the recipient address. Can only be called by current recipient.\r\n    /// @param _recipient is the new recipient address\r\n    function setRecipient(address _recipient) external {\r\n        require(_recipient != address(0), \"Zero address, Invalid!\");\r\n        require(\r\n            // Make sure current recipient is sending this\r\n            msg.sender == recipient,\r\n            \"R\"\r\n        );\r\n        recipient = _recipient;\r\n    }\r\n\r\n    function claim() external   {\r\n        require(msg.sender == recipient, 'R');\r\n        _claim();\r\n    }\r\n\r\n    /// @dev If the user leaves steer then steer can cut off the user's funds from that point on.\r\n    function cutOffFunds() external {\r\n        require(msg.sender == owner);\r\n        if (block.timestamp >= vestingCliff) {\r\n            _claim();\r\n        }\r\n\r\n        IERC20(steerToken).safeTransfer(\r\n            owner,\r\n            IERC20(steerToken).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    /// @dev User can call this function to get the voting power of the tokens that are vested.\r\n    function getVotingPowerForVestedTokens() external {\r\n        ISteerToken(steerToken).delegate(recipient);\r\n    }\r\n\r\n    /// @dev Use this function to claim the claimable tokens.\r\n    function _claim() internal {\r\n        require(block.timestamp >= vestingCliff, \"T\");\r\n        uint256 amount;\r\n        if (block.timestamp >= vestingEnd) {\r\n            amount = IERC20(steerToken).balanceOf(address(this));\r\n        } else {\r\n            // Amount = accrued earnings since last update\r\n            amount =\r\n                (vestingAmount * (block.timestamp - lastUpdate)) /\r\n                (vestingEnd - vestingBegin);\r\n\r\n            // Update lastUpdate to current timestamp\r\n            lastUpdate = block.timestamp;\r\n        }\r\n        IERC20(steerToken).safeTransfer(recipient, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ITreasuryVester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\ninterface ISteerToken {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address dst, uint256 rawAmount) external returns (bool);\r\n\r\n    function delegate(address delegatee) external;\r\n}\r\n\r\ninterface ITreasuryVester {\r\n    function setRecipient(address _recipient) external;\r\n\r\n    function claim() external;\r\n\r\n    function cutOffFunds() external;\r\n\r\n    function getVotingPowerForVestedTokens() external;\r\n}\r\n"
    },
    "contracts/interfaces/IRunnerRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\ninterface IRunnerRegistry {\r\n    /// @dev MUST be triggered when the runner amount is changed.\r\n    event RunnerAmountChanged(address runner, uint256 amount);\r\n\r\n    function bond(uint256 _amount) external;\r\n\r\n    function bondAmount() external view returns (uint256);\r\n\r\n    function bondToken() external view returns (address);\r\n\r\n    function isRunner(address _runner) external view returns (bool);\r\n\r\n    function keeperRegistry() external view returns (address);\r\n\r\n    function runners(address) external view returns (uint256);\r\n\r\n    function slash(address _runner, uint256 _amount) external;\r\n\r\n    function unbond(uint256 _amount) external;\r\n\r\n    function withdrawFreeCoin(uint256 amount) external;\r\n}\r\n"
    },
    "contracts/interfaces/IStaticJobs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.12;\r\n\r\ninterface IStaticJobs {\r\n    event JobExecuted(bytes32 jobHash);\r\n    event GasDeposited(address indexed depositor, uint256 value);\r\n    event GasWithdrawn(address indexed withdrawer, uint256 value);\r\n    event JobRegistered(\r\n        bytes[] jobInfo,\r\n        address[] targetAddresses,\r\n        bytes32 jobHash,\r\n        string name,\r\n        string ipfsForJobDetails\r\n    );\r\n    event JobToggledByCreator(bytes32 jobHash, uint256 toggle);\r\n\r\n    function registerJob(\r\n        bytes[] calldata _jobInfo,\r\n        address[] calldata _targetAddresses,\r\n        string memory _name,\r\n        string memory _ipfsForJobDetails\r\n    ) external;\r\n\r\n    function executeJob(\r\n        bytes[] memory _jobInfo,\r\n        address[] memory _targetAddresses\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/ISteerToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\ninterface ISteerToken {\r\n    function createSnapshot() external returns (uint256);\r\n\r\n    function verifyVote(\r\n        string memory mailTo,\r\n        string memory mailContents,\r\n        bytes memory signature\r\n    ) external returns (address);\r\n}\r\n"
    },
    "contracts/interfaces/IWhitelistRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\n\r\ninterface IWhitelistRegistry {\r\n    event PermissionsAdded(\r\n        address whitelistManager,\r\n        address vault,\r\n        address[] addressesAdded\r\n    );\r\n    event PermissionsRemoved(\r\n        address whitelistManager,\r\n        address vault,\r\n        address[] addressesRemoved\r\n    );\r\n    event ManagerAdded(address vaultAddress, address manager);\r\n\r\n    function addPermissions(\r\n        address _vaultAddress,\r\n        address[] calldata _addresses\r\n    ) external;\r\n\r\n    function registerWhitelistManager(address manager) external;\r\n\r\n    function revokePermissions(\r\n        address _vaultAddress,\r\n        address[] calldata _addresses\r\n    ) external;\r\n}\r\n"
    },
    "contracts/WhitelistRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.12;\r\nimport \"./interfaces/IWhitelistRegistry.sol\";\r\n\r\ncontract WhitelistRegistry is IWhitelistRegistry {\r\n    /**\r\n     * @dev info, per address, of permissions. 0 = no permissions, 1 = whitelisted. This is only relevant for vaults with whitelists.\r\n     */\r\n    mapping(address => mapping(address => uint256)) public permissions;\r\n\r\n    mapping(address => address) public whitelistManagers;\r\n\r\n    /**\r\n     * @dev add whitelist permissions for any number of addresses.\r\n     * @param _vaultAddress the vault whose whitelist will be edited\r\n     * @param _addresses the addresses to be added to the whitelist\r\n     */\r\n    function addPermissions(\r\n        address _vaultAddress,\r\n        address[] calldata _addresses\r\n    ) external {\r\n        // Make sure caller is authorized\r\n        require(\r\n            msg.sender == whitelistManagers[_vaultAddress],\r\n            \"Only whitelist manager can call this function\"\r\n        );\r\n\r\n        // Add permissions\r\n        uint256 addressCount = _addresses.length;\r\n        for (uint256 i; i != addressCount; ++i) {\r\n            permissions[_vaultAddress][_addresses[i]] = 1;\r\n        }\r\n        emit PermissionsAdded(msg.sender, _vaultAddress, _addresses);\r\n    }\r\n\r\n    /**\r\n     * @dev function meant to be called by contracts (usually in initializer) to register a whitelist manager for that contract\r\n     * @param manager the address of the vault's whitelist manager\r\n     * No access control, since any given contract can only modify their own data here.\r\n     */\r\n    function registerWhitelistManager(address manager) external {\r\n        whitelistManagers[msg.sender] = manager;\r\n        emit ManagerAdded(msg.sender, manager);\r\n    }\r\n\r\n    /**\r\n     * @dev add whitelist permissions for any number of addresses.\r\n     * @param _vaultAddress the vault whose whitelist will be edited\r\n     * @param _addresses the addresses to be removed from the whitelist\r\n     */\r\n    function revokePermissions(\r\n        address _vaultAddress,\r\n        address[] calldata _addresses\r\n    ) external {\r\n        // Make sure caller is authorized\r\n        require(msg.sender == whitelistManagers[_vaultAddress]);\r\n\r\n        // Remove permissions\r\n        uint256 addressCount = _addresses.length;\r\n        for (uint256 i; i != addressCount; ++i) {\r\n            permissions[_vaultAddress][_addresses[i]] = 0;\r\n        }\r\n        emit PermissionsRemoved(msg.sender, _vaultAddress, _addresses);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}